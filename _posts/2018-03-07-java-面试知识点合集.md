摘要：网上java面试知识杂乱而繁多，每次想看的时候总会挑挑拣拣许多时间就过去了，所以我对其进行一次学习，整理。  
学习：许多的基础知识掌握并不牢固，借此机会学习一发。  
整理：对知识做出合理的分类，设置目录，方便自己以后回顾时查看
<h2>目录</h2>
 - 基础篇
    - Java基础  
         <a href="#1.1.1">1.面对对象的三大特性</a>  
         <a href="#1.1.2">2.final，finally，finalize的区别</a>  
         <a href="#1.1.3">3.Exception、Error、运行时异常与一般异常有何异同</a>  
         <a href="#1.1.4">4.请写出你最常遇到的5种运行时异常</a>


<h2>正文</h2>
<h3>一、基础篇</h3>
<h4>1.1 java基础</h4>
<h5 id="1.1.1">1.面向对象的特征：封装、继承、多态  </h5>  

(1).封装：属性能够描述事物的特征，方法能够描述事物的动作。封装就是把同一类事物的共性（包括属性和方法）归到同一类中，方便使用。

封装的好处有：  
隐藏数据及实现细节，对每个属性加以不同的修饰符可以防止对信息的错误改动，更加安全。   
降低模块间的耦合度，以及代码复用。  

举个栗子：有一个类<b>车</b>，当需要使用时，只需要new一辆车，然后点击启动，前进，后退，就好。而不用知道车的轮胎多大，发动机型号，或者知道车是如何前进的。  

(2).继承：Java继承是面向对象的最显著的一个特征。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。JAVA不支持多继承，单继承使JAVA的继承关系很简单，一个类只能有一个父类，易于管理程序，父类是子类的一般化，子类是父类的特化（具体化)。

好处：提高代码复用率，以及易维护性。  

举个栗子：有一个类叫<b>动物</b>，它有属性：腿的数量。有方法：可以叫。  
新建一个他的子类<b>猫</b>，猫就自动拥有了上述属性集方法，你还可以添加一个新的属性：毛的颜色。
这样就不需要重新写一遍腿的数量，可以叫的代码。  

(3).多态：不同类对象对相同行为的不同反应，我们就把它叫做多态。 与继承相对应的是多态提供了对同一类对象差异性的处理方法，子类通过多态重写从父类继承的方法来实现子类的差异性。  

直接举个栗子：  
<pre><code>
class Animal{ 叫；}//叫是动物的一个方法  
class 猫 extend Animal{叫；}
class 狗 extend Animal{叫；}

Animal 狗 = new 狗();
Animal 猫 = new 猫();  

狗.叫();  
猫.叫();
</code></pre>  
猫和狗同样是Animal，调用同一个方法却可以得到不同的叫声。

<h5 id="1.1.2">2.final，finally，finalize的区别</h5>  
这个问题，，，我好想知道他们有什么联系。  
**final**  
final 关键字可以用来修饰变量，方法，类。  
用于变量时，此变量只能被赋值一次之后不能修改，且赋值必须在定义时或者构造方法中进行，常用来定义一个常量。  
**finally**  
finally用于异常处理，在try-catch块之后，可以不存在，存在的时候无论是否捕获错误都会执行finally块中的代码，常用于资源的释放，即无论是否捕获错误，都要将一些连接，文件关闭，将资源释放掉。
**finalize()**  
finalize()是一个定义域Object类的方法，也就是所有的java类都继承了此方法，主要用于java虚拟机进行垃圾回收，删除此对象之前对此对象调用finalize()方法。    

  
  
<h5 id="1.1.3">3.Exception、Error、运行时异常与一般异常有何异同</h5>
首先引入一张java异常相关类的类图：  
![1354020417_5176.jpg](https://i.loli.net/2018/03/16/5aaa99d019f39.jpg)
首先，所有的javaException以及Error都继承自Throwable。   
 
**Error**：表示程序无法处理的错误，大多数情况和程序员的代码无关，而是JVM相关的资源错误。发生此类错误时，程序无法继续，系统能做的只是尽力的安全退出程序。  

**Exception**：可以被应用程序捕获及处理的。  

先忘记上面的分类,java Exception通常可以分为**checked exception(可查异常）(Exception 类下除RuntimeException之外)** 和 **unchecked exception(不可查异常)(RuntimeException和Error)**。

**可查异常**：此类的异常是经常出现的，有迹可循甚至可查预测到可能会抛出的，因此编译器会强制要求我们去捕获/抛出它，显式的对其进行处理(不对其进行处理编译无法通过)。比如IOException和SQLException。  
在读写一个文件时，我们可以想象会出现哪些情况的异常，比如文件不正常关闭，此时应该怎么处理，都有迹可循。所以我们可以在编写程序时就对此类异常作出处理。  

**不可查异常**  
Error情况严重，一般发成程序都会结束。  
RuntimeException：运行时异常，RuntimeException及其子类，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。(此类异常不try-catch,不 throw 也可以通过编译。)  
比如空指针异常，我们也可以在每个可能引发空指针的地方捕获处理，但显然是不科学的，我们应该设计严谨的逻辑使得程序不会出现此类异常。  

<h5 id="1.1.4">4.请写出你最常见到的5种运行时异常</h5>
- NullPointerException - 空指针引用异常  
- ClassCastException - 类型强制转换异常。  
- IllegalArgumentException - 传递非法参数异常。  
- ArithmeticException - 算术运算异常  
- IndexOutOfBoundsException - 下标越界异常  
- NumberFormatException当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常.(属于IllegalArhumentException的子类)