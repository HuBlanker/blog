---
layout: post
category: [Java]
tags:
  - Java
---

整体的类图:

![2021-10-20-21-56-47](http://img.couplecoders.tech/2021-10-20-21-56-47.png)

## BlockingQueue 接口

### 官方注释翻译

什么是阻塞队列?

一个队列，它支持:

* 获取元素时，如果队列为空，可以等待元素入队，直到队列不为空
* 存储元素时，如果队列满了，可以等待元素出队，知道队列腾出空间

这就是一个阻塞队列了~.

阻塞队列的方法，有四种形式来处理，操作没有办法被立刻满足，但是未来某些时间点可能满足的情况:
* 抛出异常
* 返回特殊值(null/false等)
* 阻塞直到操作被满足
* 阻塞直到给定的最大等待时间. 

下表是一个总结:

方法类型 | 抛出异常 | 特殊值 | 等待 | 支持超时的等待
--- | --- | --- | --- | ---
insert | add(e) | offer(e) | put(e) | offer(e,time,unit)
remove | remove() | poll() | take() | poll(time,unit)
examine | element() | peek() | 不支持 | 不支持

阻塞队列不接受空值. 它的实现在尝试添加空值时将会抛出NPE.空值被用来表明`poll`操作错误了.


阻塞队列可以设置为有界的. 他可以有一个剩余容量，超过这个容量，不阻塞的put方法都无法成功.
没有指定容量的阻塞队列，都默认剩余的容量是`Integer.MAX_VALUE`.

阻塞队列的实现类，被设计为在生成消费模型中使用，同时支持`Collection`接口. 因此，它支持从队列中删除一个给定的元素.
然而，这些方法执行的不是很高效，而且只打算偶尔用用，主要用于队列中的消息被取消了.

阻塞队列的实现类是线程安全的. 所有入队的方法原子性的实现他们的操作，使用内部的锁或者其他形式的同步控制。然而，批量的集合操作`addAll，containsAll，retainAll，removeAll`
不是线程安全的，除非特别给它实现了一下. 所以，`addAll`方法可以在添加了其中部分元素后抛出异常.

阻塞队列本质上不识闲一些类似于`close``shutdown`方法去表明不会再有元素添加进来了. 这类的需求旺旺由子类独立实现.

比如，一个公共的策略是， 由生产者写入一个特殊值，这个特殊值将导致所有消费者中断，以此来实现上面的需求.

使用实例: 

一个常见的生产消费场景，注意阻塞队列可以线程安全的被多个生产者和消费者使用.

```java
 class Producer implements Runnable {
   private final BlockingQueue queue;
   Producer(BlockingQueue q) { queue = q; }
   public void run() {
     try {
       while (true) { queue.put(produce()); }
     } catch (InterruptedException ex) { ... handle ...}
   }
   Object produce() { ... }
 }

 class Consumer implements Runnable {
   private final BlockingQueue queue;
   Consumer(BlockingQueue q) { queue = q; }
   public void run() {
     try {
       while (true) { consume(queue.take()); }
     } catch (InterruptedException ex) { ... handle ...}
   }
   void consume(Object x) { ... }
 }

 class Setup {
   void main() {
     BlockingQueue q = new SomeQueueImplementation();
     Producer p = new Producer(q);
     Consumer c1 = new Consumer(q);
     Consumer c2 = new Consumer(q);
     new Thread(p).start();
     new Thread(c1).start();
     new Thread(c2).start();
   }
 }
```

### 接口方法

大部分方法在上面的注释中，有个表格，定义了以什么样的策略做什么操作. 这里只备注剩下的几个接口咯.

* add 
* offer
* put
* offer(time,unit)
* take
* poll
* remainingCapacity 剩余容量
* remove
* contains 是否包含
* drainTo
* drainTo(collection, int number) 从队列中移除可用元素，并且放到给定的集合中. 最多移除给定数量个.


## BlockingDeque 接口

### 官方注释翻译

和阻塞队列很像的，那么这个阻塞双端队列，我就翻译的简单点了.

首先他是一个支持阻塞操作的双端队列，当队列为空，要获取，可以阻塞。当队列满了，要写入，可以阻塞.

同样的，阻塞操作也有四种风格

* 抛出异常
* 返回特殊值
* 阻塞
* 超时的阻塞

对应的方法如下表:

**队头操作**

方法类型 | 抛出异常 | 特殊值 | 阻塞 | 超时阻塞
--- | --- | --- | --- | ---
insert | addFirst(e) | offerFirst(e) | putFirst(e)  | offerFirst(e,time,unit)
remove | removeFirst | pollFirst() | takeFirst() | pollFirst(time,unit)
examine | getFirst() | peekFirst() | 不支持 | 不支持

**队尾操作**


方法类型 | 抛出异常 | 特殊值 | 阻塞 | 超时阻塞
--- | --- | --- | --- | ---
insert | addLast(e) | offerLast(e) | putLast(e)  | offerLast(e,time,unit)
remove | removeLast | pollLast() | takeLast() | pollLast(time,unit)
examine | getLast() | peekLast() | 不支持 | 不支持

像阻塞队列一样，阻塞双端队列也是线程安全的.不允许控制，并且可以是有界的队列.

阻塞双端队列的实现，可以用作一个`FIFI的阻塞队列`。 继承自阻塞队列的方法，对应调用的阻塞双端队列的方法表如下:


方法 | 阻塞队列方法 | 等效的阻塞双端队列方法
--- | --- | ---
insert | put(e) | putLast(E)
remove | take() | takeFirst()
examine | peek() | peekFirst().

### 接口方法

* addFirst 队首添加
* addLast 队尾添加
* offerFirst 队首添加
* offerLast 队尾添加
* putFirst 阻塞版本的队首添加
* putLast 阻塞版本的队尾添加
* offerFirst 超时阻塞版本的队首添加 
* offerLast 超时阻塞版本的队尾巴添加
* takeFirst 超时版本的队首移除
* takeLast 超时版本的队尾移除
* pollFirst 队首移除
* pollLast 队尾移除
* removeFirstOccurrence 移除队首
* removeLastOccurrence 移除队尾
* add 添加,接下来的8个方法继承自阻塞队列
* offer 添加
* put 添加
* offer 添加
* remove 移除
* poll 移除
* take 移除
* poll 移除
* element 获取元素
* peek 获取元素
* remove 移除
* contains 是否包含
* size 容量
* iterator 迭代器
* push 添加

## TransferQueue 接口

### 官方注释翻译

一个支持让生产者阻塞等待消费者获取元素的阻塞队列. 可能用在消息传递系统中， 生产者有时候需要等待消费者调用`take`或者`poll`来获取元素,另外一些时候，入队元素可以不用等待消费者获取.

非阻塞的和超时阻塞的版本也是提供了的，使用`tryTransfer`.

一个`TransferQueue`也可以查询当前的消费者数量，这与`peek`是一个相反的操作.

像其他的阻塞队列一样，`TransferQueue`也可以是有界的。这种情况下，一个尝试传输的操作可能会首先阻塞等待可用的空间，然后阻塞等待对应的消费者.
注意，在一个容量为0的传输队列中，`put`和`transfer`操作实际上都是同步的.

### 接口方法

* tryTransfer 尝试传输
* transfer 传输
* tryTransfer 尝试传输
* hasWaitingConsumer 是否有等待的消费者
* getWaitingConsumerCount 等待的消费者的数量

## ArrayBlockingQueue

### 官方注释翻译

使用数组实现的一个有界的阻塞队列，这个队列按照FIFO的顺序提供元素.

队列的第一个元素，也就是队列头部，是入队最久的元素，队列尾部是入队时间最少的元素. 新元素将插入到队列的尾部，队列的获取操作将从队列的头部获取元素.

这是一个经典的有界缓冲，一个固定大小的数组，持有元素，被生产者插入元素和被消费者获取元素. 一旦创建，容量就不能再更改了.

向一个满了的队列插入元素，将会导致阻塞，从一个空的队列中获取元素，也会阻塞.

这个类支持了可选的生产消费线程阻塞公平的等待顺序策略，默认情况下，这个顺序是不保证的.

但是，创建队列时，指定了公平的策略，那么就会保证线程以FIFO的顺序来访问了. 

公平策略通常会降低吞吐量但是减少不确定性，以及能够避免过度的饥饿.

这个类及其迭代器实现了集合类和迭代器的所有可选方法.

这个类也是Java集合框架的一部分.

### 源码

#### 定义

```java
public class ArrayBlockingQueue<E> extends AbstractQueue<E>
        implements BlockingQueue<E>, java.io.Serializable {
```

`ArrayBlockingQueue`继承自`AbstractQueue`，拥有队列的常见方法，同时实现了`BlockingQueue`接口，有阻塞队列相关特性.

#### 属性

```java
    /** The queued items */
    // 用数组保存的队列中的元素
    final Object[] items;

    /** items index for next take, poll, peek or remove */
    // 下一个移除的元素的索引，代指队首
    int takeIndex;

    /** items index for next put, offer, or add */
    // 下一个添加的元素的索引，代指队尾
    int putIndex;

    /** Number of elements in the queue */
    // 当前队列中的元素数量
    int count;

    /*
     * Concurrency control uses the classic two-condition algorithm
     * found in any textbook.
     */

    // 锁
    /** Main lock guarding all access */
    final ReentrantLock lock;

    /** Condition for waiting takes */
    // 等待条件，消费者等待
    private final Condition notEmpty;

    /** Condition for waiting puts */
    // 等待条件，生产者等待
    private final Condition notFull;

    /**
     * Shared state for currently active iterators, or null if there
     * are known not to be any.  Allows queue operations to update
     * iterator state.
     */
    // 迭代器？
    transient Itrs itrs;

```

一些核心属性的介绍，其中由数组保存队列中的元素，两个下标分别指向队头和队尾.

#### 构造方法

```java

    // 指定容量
    public ArrayBlockingQueue(int capacity) {
        this(capacity, false);
    }

    // 指定容量和公平性策略，默认的公平性策略是非公平
    public ArrayBlockingQueue(int capacity, boolean fair) {
        if (capacity <= 0)
            throw new IllegalArgumentException();
        this.items = new Object[capacity];
        lock = new ReentrantLock(fair);
        notEmpty = lock.newCondition();
        notFull =  lock.newCondition();
    }

    // 用一个给定的集合初始化阻塞队列，除了初始化属性外，还将集合中的所有元素放入队列
    public ArrayBlockingQueue(int capacity, boolean fair,
                              Collection<? extends E> c) {
        this(capacity, fair);

        final ReentrantLock lock = this.lock;
        lock.lock(); // Lock only for visibility, not mutual exclusion
        try {
            final Object[] items = this.items;
            int i = 0;
            try {
                for (E e : c)
                    items[i++] = Objects.requireNonNull(e);
            } catch (ArrayIndexOutOfBoundsException ex) {
                throw new IllegalArgumentException();
            }
            count = i;
            putIndex = (i == capacity) ? 0 : i;
        } finally {
            lock.unlock();
        }
    }

```

可以指定阻塞队列的容量，以及公平性策略.

此外还支持将一个给定的集合中的所有元素放入队列中.

#### 入队操作 

* add
* put
* offer
* offer(time,unit)


这四个方法，分别对应阻塞队列处理`队列满了却还是要入队`情况的四种策略.

##### add 抛出异常

```java

  public boolean add(E e) {
    return super.add(e);
  }
```

调用父类`AbstractQueue`的`add`方法，如果队列满了就抛出异常. 

##### offer 返回特殊值

如果成功，就返回true，失败返回false。

```java

    public boolean offer(E e) {
        Objects.requireNonNull(e);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            if (count == items.length)
                return false;
            else {
                enqueue(e);
                return true;
            }
        } finally {
            lock.unlock();
        }
    }
```

首先加锁，然后判断当前队列是否满了，如果满了返回false。 否则调用`enqueue`进入入队操作.

```java

    private void enqueue(E e) {
        // assert lock.isHeldByCurrentThread();
        // assert lock.getHoldCount() == 1;
        // assert items[putIndex] == null;
        final Object[] items = this.items;
        // 放入队尾
        items[putIndex] = e;
        // 如果超过数组长度，就返回到0
        if (++putIndex == items.length) putIndex = 0;
        // 元素＋1
        count++;
        // 队列不为空，唤醒等待者
        notEmpty.signal();
    }
```

这是一个核心的入队方法，多种添加元素的方法实际上都是调用的它.

##### put 超时

```java

    public void put(E e) throws InterruptedException {
        Objects.requireNonNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == items.length)
                notFull.await();
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
```

如果队列是满的，直接在`notFull`条件上await等待. 被唤醒后进行入队操作. 

##### offer(e,time,unit) 支持超时的等待操作

```java

    public boolean offer(E e, long timeout, TimeUnit unit)
        throws InterruptedException {

        Objects.requireNonNull(e);
        long nanos = unit.toNanos(timeout);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            // 如果队列满了
            while (count == items.length) {
                // 且超时了，返回0
                if (nanos <= 0L)
                    return false;
                nanos = notFull.awaitNanos(nanos);
            }
            enqueue(e);
            return true;
        } finally {
            lock.unlock();
        }
    }
```

如果队列满了，就自旋. 如果超时了，返回false。没有超时就在`notFull`条件上进行等待. 
被唤醒后进行入队操作.

#### 出队操作

##### poll 返回特殊值

```java
    public E poll() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return (count == 0) ? null : dequeue();
        } finally {
            lock.unlock();
        }
    }
```

如果队列为空，就返回`null`. 这就是为啥阻塞队列不支持`null`元素的原因，因为`null`值被用来代表队列中为空.
不为空则进行出队操作.

```java
    private E dequeue() {
        // assert lock.isHeldByCurrentThread();
        // assert lock.getHoldCount() == 1;
        // assert items[takeIndex] != null;
        final Object[] items = this.items;
        @SuppressWarnings("unchecked")
        // 从队首获取第一个元素
        E e = (E) items[takeIndex];
        // 队首变为空
        items[takeIndex] = null;
        // 队首指针移动
        if (++takeIndex == items.length) takeIndex = 0;
        // 元素数量-1
        count--;
        // 告诉迭代器
        if (itrs != null)
            itrs.elementDequeued();
        // 通知等待的生产者，队列中有空闲位置了
        notFull.signal();
        return e;
    }
```

这是核心的出队操作，按照注释里的步骤完成多个相关属性的改变. 出队操作核心上都是调用的这个方法.

##### take 阻塞

```java

    public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == 0)
                notEmpty.await();
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
```

如果队列为空，则在`notEmpty`条件上等待，被唤醒后执行出队操作。

##### poll(time,unit) 超时版本的阻塞

```java

    public E poll(long timeout, TimeUnit unit) throws InterruptedException {
        long nanos = unit.toNanos(timeout);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == 0) {
                if (nanos <= 0L)
                    return null;
                nanos = notEmpty.awaitNanos(nanos);
            }
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
```

如果队列为空，且超时了，就返回null。如果没有超时，就等待指定的毫秒数.

#### 查看系列方法

* size 直接返回count值即可.
* peek 返回队首的元素，但是不弹出,可以用来查看当前队首的元素
* remainingCapacity 返回剩余容量

#### 总结

`ArrayBlockingQueue` 是一个比较简单的阻塞队列实现.

由数组保存元素，队首队尾两个指针负责控制入队和出队的位置.

线程安全由`ReentrantLock`保证，内部所有对数组的读取及改动均需要加锁.

阻塞功能由锁带的`Condition`实现，两个`Condition`分别负责`队列不为空``队列没有满`，分别使生产者和消费者阻塞，及条件满足后的唤醒功能.


<br>


完。
<br>
<br>
<br>


## 联系我
最后，欢迎关注我的个人公众号【 呼延十 】，会不定期更新很多后端工程师的学习笔记。
也欢迎直接公众号私信或者邮箱联系我，一定知无不言，言无不尽。
![](http://img.couplecoders.tech/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png)


<br>
<br>




**以上皆为个人所思所得，如有错误欢迎评论区指正。**


**欢迎转载，烦请署名并保留原文链接。**


**联系邮箱：huyanshi2580@gmail.com**


**更多学习笔记见个人博客或关注微信公众号 &lt;呼延十 &gt;------><a href="{{ site.baseurl }}/">呼延十</a>**