---
layout: post category: [Java]
tags:

- Java

---

整体的类图:

![2021-10-20-21-56-47](http://img.couplecoders.tech/2021-10-20-21-56-47.png)

## BlockingQueue 接口

### 官方注释翻译

什么是阻塞队列?

一个队列，它支持:

* 获取元素时，如果队列为空，可以等待元素入队，直到队列不为空
* 存储元素时，如果队列满了，可以等待元素出队，知道队列腾出空间

这就是一个阻塞队列了~.

阻塞队列的方法，有四种形式来处理，操作没有办法被立刻满足，但是未来某些时间点可能满足的情况:

* 抛出异常
* 返回特殊值(null/false等)
* 阻塞直到操作被满足
* 阻塞直到给定的最大等待时间.

下表是一个总结:

方法类型 | 抛出异常 | 特殊值 | 等待 | 支持超时的等待
--- | --- | --- | --- | ---
insert | add(e) | offer(e) | put(e) | offer(e,time,unit)
remove | remove() | poll() | take() | poll(time,unit)
examine | element() | peek() | 不支持 | 不支持

阻塞队列不接受空值. 它的实现在尝试添加空值时将会抛出NPE.空值被用来表明`poll`操作错误了.

阻塞队列可以设置为有界的. 他可以有一个剩余容量，超过这个容量，不阻塞的put方法都无法成功. 没有指定容量的阻塞队列，都默认剩余的容量是`Integer.MAX_VALUE`.

阻塞队列的实现类，被设计为在生成消费模型中使用，同时支持`Collection`接口. 因此，它支持从队列中删除一个给定的元素. 然而，这些方法执行的不是很高效，而且只打算偶尔用用，主要用于队列中的消息被取消了.

阻塞队列的实现类是线程安全的. 所有入队的方法原子性的实现他们的操作，使用内部的锁或者其他形式的同步控制。然而，批量的集合操作`addAll，containsAll，retainAll，removeAll`
不是线程安全的，除非特别给它实现了一下. 所以，`addAll`方法可以在添加了其中部分元素后抛出异常.

阻塞队列本质上不识闲一些类似于`close``shutdown`方法去表明不会再有元素添加进来了. 这类的需求旺旺由子类独立实现.

比如，一个公共的策略是， 由生产者写入一个特殊值，这个特殊值将导致所有消费者中断，以此来实现上面的需求.

使用实例:

一个常见的生产消费场景，注意阻塞队列可以线程安全的被多个生产者和消费者使用.

```java
 class Producer implements Runnable {
    private final BlockingQueue queue;

    Producer(BlockingQueue q) {
        queue = q;
    }

    public void run() {
        try {
            while (true) {
                queue.put(produce());
            }
        } catch (InterruptedException ex) { ...handle ...}
    }

    Object produce() { ...}
}

class Consumer implements Runnable {
    private final BlockingQueue queue;

    Consumer(BlockingQueue q) {
        queue = q;
    }

    public void run() {
        try {
            while (true) {
                consume(queue.take());
            }
        } catch (InterruptedException ex) { ...handle ...}
    }

    void consume(Object x) { ...}
}

class Setup {
    void main() {
        BlockingQueue q = new SomeQueueImplementation();
        Producer p = new Producer(q);
        Consumer c1 = new Consumer(q);
        Consumer c2 = new Consumer(q);
        new Thread(p).start();
        new Thread(c1).start();
        new Thread(c2).start();
    }
}
```

### 接口方法

大部分方法在上面的注释中，有个表格，定义了以什么样的策略做什么操作. 这里只备注剩下的几个接口咯.

* add
* offer
* put
* offer(time,unit)
* take
* poll
* remainingCapacity 剩余容量
* remove
* contains 是否包含
* drainTo
* drainTo(collection, int number) 从队列中移除可用元素，并且放到给定的集合中. 最多移除给定数量个.

## BlockingDeque 接口

### 官方注释翻译

和阻塞队列很像的，那么这个阻塞双端队列，我就翻译的简单点了.

首先他是一个支持阻塞操作的双端队列，当队列为空，要获取，可以阻塞。当队列满了，要写入，可以阻塞.

同样的，阻塞操作也有四种风格

* 抛出异常
* 返回特殊值
* 阻塞
* 超时的阻塞

对应的方法如下表:

**队头操作**

方法类型 | 抛出异常 | 特殊值 | 阻塞 | 超时阻塞
--- | --- | --- | --- | ---
insert | addFirst(e) | offerFirst(e) | putFirst(e)  | offerFirst(e,time,unit)
remove | removeFirst | pollFirst() | takeFirst() | pollFirst(time,unit)
examine | getFirst() | peekFirst() | 不支持 | 不支持

**队尾操作**

方法类型 | 抛出异常 | 特殊值 | 阻塞 | 超时阻塞
--- | --- | --- | --- | ---
insert | addLast(e) | offerLast(e) | putLast(e)  | offerLast(e,time,unit)
remove | removeLast | pollLast() | takeLast() | pollLast(time,unit)
examine | getLast() | peekLast() | 不支持 | 不支持

像阻塞队列一样，阻塞双端队列也是线程安全的.不允许控制，并且可以是有界的队列.

阻塞双端队列的实现，可以用作一个`FIFI的阻塞队列`。 继承自阻塞队列的方法，对应调用的阻塞双端队列的方法表如下:

方法 | 阻塞队列方法 | 等效的阻塞双端队列方法
--- | --- | ---
insert | put(e) | putLast(E)
remove | take() | takeFirst()
examine | peek() | peekFirst().

### 接口方法

* addFirst 队首添加
* addLast 队尾添加
* offerFirst 队首添加
* offerLast 队尾添加
* putFirst 阻塞版本的队首添加
* putLast 阻塞版本的队尾添加
* offerFirst 超时阻塞版本的队首添加
* offerLast 超时阻塞版本的队尾巴添加
* takeFirst 超时版本的队首移除
* takeLast 超时版本的队尾移除
* pollFirst 队首移除
* pollLast 队尾移除
* removeFirstOccurrence 移除队首
* removeLastOccurrence 移除队尾
* add 添加,接下来的8个方法继承自阻塞队列
* offer 添加
* put 添加
* offer 添加
* remove 移除
* poll 移除
* take 移除
* poll 移除
* element 获取元素
* peek 获取元素
* remove 移除
* contains 是否包含
* size 容量
* iterator 迭代器
* push 添加

## TransferQueue 接口

### 官方注释翻译

一个支持让生产者阻塞等待消费者获取元素的阻塞队列. 可能用在消息传递系统中， 生产者有时候需要等待消费者调用`take`或者`poll`来获取元素,另外一些时候，入队元素可以不用等待消费者获取.

非阻塞的和超时阻塞的版本也是提供了的，使用`tryTransfer`.

一个`TransferQueue`也可以查询当前的消费者数量，这与`peek`是一个相反的操作.

像其他的阻塞队列一样，`TransferQueue`也可以是有界的。这种情况下，一个尝试传输的操作可能会首先阻塞等待可用的空间，然后阻塞等待对应的消费者. 注意，在一个容量为0的传输队列中，`put`和`transfer`
操作实际上都是同步的.

### 接口方法

* tryTransfer 尝试传输
* transfer 传输
* tryTransfer 尝试传输
* hasWaitingConsumer 是否有等待的消费者
* getWaitingConsumerCount 等待的消费者的数量

## ArrayBlockingQueue

### 官方注释翻译

使用数组实现的一个有界的阻塞队列，这个队列按照FIFO的顺序提供元素.

队列的第一个元素，也就是队列头部，是入队最久的元素，队列尾部是入队时间最少的元素. 新元素将插入到队列的尾部，队列的获取操作将从队列的头部获取元素.

这是一个经典的有界缓冲，一个固定大小的数组，持有元素，被生产者插入元素和被消费者获取元素. 一旦创建，容量就不能再更改了.

向一个满了的队列插入元素，将会导致阻塞，从一个空的队列中获取元素，也会阻塞.

这个类支持了可选的生产消费线程阻塞公平的等待顺序策略，默认情况下，这个顺序是不保证的.

但是，创建队列时，指定了公平的策略，那么就会保证线程以FIFO的顺序来访问了.

公平策略通常会降低吞吐量但是减少不确定性，以及能够避免过度的饥饿.

这个类及其迭代器实现了集合类和迭代器的所有可选方法.

这个类也是Java集合框架的一部分.

### 源码

#### 定义

```java
public class ArrayBlockingQueue<E> extends AbstractQueue<E>
        implements BlockingQueue<E>, java.io.Serializable {
```

`ArrayBlockingQueue`继承自`AbstractQueue`，拥有队列的常见方法，同时实现了`BlockingQueue`接口，有阻塞队列相关特性.

#### 属性

```java
    /** The queued items */
// 用数组保存的队列中的元素
final Object[]items;

        /** items index for next take, poll, peek or remove */
        // 下一个移除的元素的索引，代指队首
        int takeIndex;

        /** items index for next put, offer, or add */
        // 下一个添加的元素的索引，代指队尾
        int putIndex;

        /** Number of elements in the queue */
        // 当前队列中的元素数量
        int count;

/*
 * Concurrency control uses the classic two-condition algorithm
 * found in any textbook.
 */

// 锁
/** Main lock guarding all access */
final ReentrantLock lock;

/** Condition for waiting takes */
// 等待条件，消费者等待
private final Condition notEmpty;

/** Condition for waiting puts */
// 等待条件，生产者等待
private final Condition notFull;

/**
 * Shared state for currently active iterators, or null if there
 * are known not to be any.  Allows queue operations to update
 * iterator state.
 */
// 迭代器？
transient Itrs itrs;

```

一些核心属性的介绍，其中由数组保存队列中的元素，两个下标分别指向队头和队尾.

#### 构造方法

```java

// 指定容量
public ArrayBlockingQueue(int capacity){
        this(capacity,false);
        }

// 指定容量和公平性策略，默认的公平性策略是非公平
public ArrayBlockingQueue(int capacity,boolean fair){
        if(capacity<=0)
        throw new IllegalArgumentException();
        this.items=new Object[capacity];
        lock=new ReentrantLock(fair);
        notEmpty=lock.newCondition();
        notFull=lock.newCondition();
        }

// 用一个给定的集合初始化阻塞队列，除了初始化属性外，还将集合中的所有元素放入队列
public ArrayBlockingQueue(int capacity,boolean fair,
        Collection<?extends E> c){
        this(capacity,fair);

final ReentrantLock lock=this.lock;
        lock.lock(); // Lock only for visibility, not mutual exclusion
        try{
final Object[]items=this.items;
        int i=0;
        try{
        for(E e:c)
        items[i++]=Objects.requireNonNull(e);
        }catch(ArrayIndexOutOfBoundsException ex){
        throw new IllegalArgumentException();
        }
        count=i;
        putIndex=(i==capacity)?0:i;
        }finally{
        lock.unlock();
        }
        }

```

可以指定阻塞队列的容量，以及公平性策略.

此外还支持将一个给定的集合中的所有元素放入队列中.

#### 入队操作

* add
* put
* offer
* offer(time,unit)

这四个方法，分别对应阻塞队列处理`队列满了却还是要入队`情况的四种策略.

##### add 抛出异常

```java

public boolean add(E e){
        return super.add(e);
        }
```

调用父类`AbstractQueue`的`add`方法，如果队列满了就抛出异常.

##### offer 返回特殊值

如果成功，就返回true，失败返回false。

```java

public boolean offer(E e){
        Objects.requireNonNull(e);
final ReentrantLock lock=this.lock;
        lock.lock();
        try{
        if(count==items.length)
        return false;
        else{
        enqueue(e);
        return true;
        }
        }finally{
        lock.unlock();
        }
        }
```

首先加锁，然后判断当前队列是否满了，如果满了返回false。 否则调用`enqueue`进入入队操作.

```java

private void enqueue(E e){
// assert lock.isHeldByCurrentThread();
// assert lock.getHoldCount() == 1;
// assert items[putIndex] == null;
final Object[]items=this.items;
        // 放入队尾
        items[putIndex]=e;
        // 如果超过数组长度，就返回到0
        if(++putIndex==items.length)putIndex=0;
        // 元素＋1
        count++;
        // 队列不为空，唤醒等待者
        notEmpty.signal();
        }
```

这是一个核心的入队方法，多种添加元素的方法实际上都是调用的它.

##### put 超时

```java

public void put(E e)throws InterruptedException{
        Objects.requireNonNull(e);
final ReentrantLock lock=this.lock;
        lock.lockInterruptibly();
        try{
        while(count==items.length)
        notFull.await();
        enqueue(e);
        }finally{
        lock.unlock();
        }
        }
```

如果队列是满的，直接在`notFull`条件上await等待. 被唤醒后进行入队操作.

##### offer(e,time,unit) 支持超时的等待操作

```java

public boolean offer(E e,long timeout,TimeUnit unit)
        throws InterruptedException{

        Objects.requireNonNull(e);
        long nanos=unit.toNanos(timeout);
final ReentrantLock lock=this.lock;
        lock.lockInterruptibly();
        try{
        // 如果队列满了
        while(count==items.length){
        // 且超时了，返回0
        if(nanos<=0L)
        return false;
        nanos=notFull.awaitNanos(nanos);
        }
        enqueue(e);
        return true;
        }finally{
        lock.unlock();
        }
        }
```

如果队列满了，就自旋. 如果超时了，返回false。没有超时就在`notFull`条件上进行等待. 被唤醒后进行入队操作.

#### 出队操作

##### poll 返回特殊值

```java
    public E poll(){
final ReentrantLock lock=this.lock;
        lock.lock();
        try{
        return(count==0)?null:dequeue();
        }finally{
        lock.unlock();
        }
        }
```

如果队列为空，就返回`null`. 这就是为啥阻塞队列不支持`null`元素的原因，因为`null`值被用来代表队列中为空. 不为空则进行出队操作.

```java
    private E dequeue(){
// assert lock.isHeldByCurrentThread();
// assert lock.getHoldCount() == 1;
// assert items[takeIndex] != null;
final Object[]items=this.items;
@SuppressWarnings("unchecked")
// 从队首获取第一个元素
        E e=(E)items[takeIndex];
                // 队首变为空
                items[takeIndex]=null;
                // 队首指针移动
                if(++takeIndex==items.length)takeIndex=0;
                // 元素数量-1
                count--;
                // 告诉迭代器
                if(itrs!=null)
                itrs.elementDequeued();
                // 通知等待的生产者，队列中有空闲位置了
                notFull.signal();
                return e;
                }
```

这是核心的出队操作，按照注释里的步骤完成多个相关属性的改变. 出队操作核心上都是调用的这个方法.

##### take 阻塞

```java

public E take()throws InterruptedException{
final ReentrantLock lock=this.lock;
        lock.lockInterruptibly();
        try{
        while(count==0)
        notEmpty.await();
        return dequeue();
        }finally{
        lock.unlock();
        }
        }
```

如果队列为空，则在`notEmpty`条件上等待，被唤醒后执行出队操作。

##### poll(time,unit) 超时版本的阻塞

```java

public E poll(long timeout,TimeUnit unit)throws InterruptedException{
        long nanos=unit.toNanos(timeout);
final ReentrantLock lock=this.lock;
        lock.lockInterruptibly();
        try{
        while(count==0){
        if(nanos<=0L)
        return null;
        nanos=notEmpty.awaitNanos(nanos);
        }
        return dequeue();
        }finally{
        lock.unlock();
        }
        }
```

如果队列为空，且超时了，就返回null。如果没有超时，就等待指定的毫秒数.

#### 查看系列方法

* size 直接返回count值即可.
* peek 返回队首的元素，但是不弹出,可以用来查看当前队首的元素
* remainingCapacity 返回剩余容量

#### 总结

`ArrayBlockingQueue` 是一个比较简单的阻塞队列实现.

由数组保存元素，队首队尾两个指针负责控制入队和出队的位置.

线程安全由`ReentrantLock`保证，内部所有对数组的读取及改动均需要加锁.

阻塞功能由锁带的`Condition`实现，两个`Condition`分别负责`队列不为空``队列没有满`，分别使生产者和消费者阻塞，及条件满足后的唤醒功能.

## LinkedBlockingQueue

### 官方注释翻译

一个用链表实现的可以是有界的阻塞队列. 元素排序为FIFO.

队头元素是在队列中时间最长的元素，队尾元素是在队列中时间最短的元素.

新的元素插入到队列尾部，获取操作从队头获取元素.

链表实现的队列通常比数组实现的有更高的吞吐量，但是在高并发情况下，性能更加不可预测.

通常的容量边界提供了一个扩容队列的操作， 默认情况下，容量是: Integer.MAX_VALUE. 链表的节点在每一次插入操作时动态创建，除非这次插入会超过队列容量.

这个类和他的迭代器实现了`Collection`和`Iterator`接口的所有可选方法.这个类也是Java集合框架的一部分.

### 源码

#### 定义

```java
public class LinkedBlockingQueue<E> extends AbstractQueue<E>
        implements BlockingQueue<E>, java.io.Serializable {
```

实现了基础的`AbstractQueue`接口，因此具有所有的队列常用方法，同时实现了`BlockingQueue`接口，也具有阻塞队列的所有特性.

#### 链表节点定义

```java
    static class Node<E> {
    E item;

    /**
     * One of:
     * - the real successor Node
     * - this Node, meaning the successor is head.next
     * - null, meaning there is no successor (this is the last node)
     */
    Node<E> next;

    Node(E x) {
        item = x;
    }
}
```

比较简单的一个定义, 持有当前的元素及下一个节点的指针.

这个指针有三种情况:

* Node 一个真实的节点
* 当前节点， 意味着当前节点的下一个，是`head.next`.
* null 意味着没有后继节点了. 当前节点是最后一个节点.

#### 属性

```java
// 初始设定的容量
private final int capacity;

// 当前数量
private final AtomicInteger count=new AtomicInteger();

/**
 * Head of linked list.
 * Invariant: head.item == null
 */
// 头结点，头结点的item一定为null
transient Node<E> head;

/**
 * Tail of linked list.
 * Invariant: last.next == null
 */
// 尾节点，尾节点的next指针一定是null
private transient Node<E> last;

/** Lock held by take, poll, etc */
// 获取元素时的锁
private final ReentrantLock takeLock=new ReentrantLock();

/** Wait queue for waiting takes */
// 不为空的等待条件
private final Condition notEmpty=takeLock.newCondition();

/** Lock held by put, offer, etc */
// 写入元素时的锁
private final ReentrantLock putLock=new ReentrantLock();

/** Wait queue for waiting puts */
// 队列有空闲的等待条件
private final Condition notFull=putLock.newCondition();
```

* 首先保存了最大容量与当前容量，用来实现有界队列。
* 其次保存了头结点和尾节点，用来实现链表保存实际的元素
* 最后持有两把锁，分别锁队头和队尾，用来保证线程安全
* 每把锁有对应的等待条件，用来休眠/唤醒线程，用来实现线程阻塞

#### 构造方法

```java

public LinkedBlockingQueue(){
        this(Integer.MAX_VALUE);
        }

public LinkedBlockingQueue(int capacity){
        if(capacity<=0)throw new IllegalArgumentException();
        this.capacity=capacity;
        last=head=new Node<E>(null);
        }

public LinkedBlockingQueue(Collection<?extends E> c){
        this(Integer.MAX_VALUE);
final ReentrantLock putLock=this.putLock;
        putLock.lock(); // Never contended, but necessary for visibility
        try{
        int n=0;
        for(E e:c){
        if(e==null)
        throw new NullPointerException();
        if(n==capacity)
        throw new IllegalStateException("Queue full");
        enqueue(new Node<E>(e));
        ++n;
        }
        count.set(n);
        }finally{
        putLock.unlock();
        }
        }

```

提供了三个构造方法，可以指定容量，然后初始化头结点.

此外还支持将给定的集合初始化进队列.

#### 入队操作

##### add 抛出异常

调用的`AbstractQueue`的方法，如果队列满了直接抛出异常.

##### offer(e) 返回true/false

```java
    public boolean offer(E e){
        if(e==null)throw new NullPointerException();
// 当前数量
final AtomicInteger count=this.count;
        // 如果队列满了，返回false
        if(count.get()==capacity)
        return false;
final int c;
// 初始化当前节点
final Node<E> node=new Node<E>(e);
// 写入锁的加锁
final ReentrantLock putLock=this.putLock;
        putLock.lock();
        try{
        // 加锁后再次检查一下容量
        if(count.get()==capacity)
        return false;
        // 入队操作
        enqueue(node);
        // 数量+1
        c=count.getAndIncrement();
        // 如果还有空闲容量，唤醒等待的其他生产者
        if(c+1<capacity)
        notFull.signal();
        }finally{
        putLock.unlock();
        }
        // 如果当前写入前，容量为0，也就是当前节点是给空队列放入的第一个元素，唤醒等待的消费者
        if(c==0)
        signalNotEmpty();
        return true;
        }
```

两次检查队列容量，如果超出限制，就返回false。否则的话调用入队操作. 此外，如果当前元素，是给空队列放入的第一个元素，唤醒其他消费者，告诉他们，队列不为空了.

```java
    private void enqueue(Node<E> node){
        // assert putLock.isHeldByCurrentThread();
        // assert last.next == null;
        // 将当前节点链接在最后一个节点的下一个
        last=last.next=node;
        }
```

这是核心的元素入队操作，比较简单，只是将当前元素链接在当前链表的尾部即可.

##### put 阻塞

```java

public void put(E e)throws InterruptedException{
        if(e==null)throw new NullPointerException();
final int c;
// 创建当前节点
final Node<E> node=new Node<E>(e);
final ReentrantLock putLock=this.putLock;
final AtomicInteger count=this.count;
        // 写入的锁加锁
        putLock.lockInterruptibly();
        try{
        /*
         * Note that count is used in wait guard even though it is
         * not protected by lock. This works because count can
         * only decrease at this point (all other puts are shut
         * out by lock), and we (or some other waiting put) are
         * signalled if it ever changes from capacity. Similarly
         * for all other uses of count in other wait guards.
         */
        // 如果队列满了，自旋且等待
        while(count.get()==capacity){
        notFull.await();
        }
        // 被唤醒后，说明队列不满了，执行入队操作
        enqueue(node);
        c=count.getAndIncrement();
        // 如果队列不满，协助唤醒其他生产者
        if(c+1<capacity)
        notFull.signal();
        }finally{
        putLock.unlock();
        }
        // 如果当前元素是第一个元素，唤醒其他的消费者
        if(c==0)
        signalNotEmpty();
        }
```

总体和`offer`很相似，只是在发现队列已经满了的时候，不是返回false。而是在`notFull`条件上进行等待，等待别的线程唤醒. 唤醒后就可以继续入队了。

##### offer(e,time,unit)

```java

public boolean offer(E e,long timeout,TimeUnit unit)
        throws InterruptedException{

        if(e==null)throw new NullPointerException();
        long nanos=unit.toNanos(timeout);
final int c;
final ReentrantLock putLock=this.putLock;
final AtomicInteger count=this.count;
        putLock.lockInterruptibly();
        try{
        while(count.get()==capacity){
        if(nanos<=0L)
        return false;
        nanos=notFull.awaitNanos(nanos);
        }
        enqueue(new Node<E>(e));
        c=count.getAndIncrement();
        if(c+1<capacity)
        notFull.signal();
        }finally{
        putLock.unlock();
        }
        if(c==0)
        signalNotEmpty();
        return true;
        }
```

和`put`相似，只是在返现队列满的情况下，如果已经超时，就返回false，如果没有超时，就让当前线程休眠给定的毫秒数，再次判断是否能够入队元素.

#### 出队操作

```java

public E poll(){
// 当前数量
final AtomicInteger count=this.count;
        // 如果当前为空，返回null.
        if(count.get()==0)
        return null;
final E x;
final int c;
final ReentrantLock takeLock=this.takeLock;
        // 读锁加锁
        takeLock.lock();
        try{
        // 再次检查队列是否为空
        if(count.get()==0)
        return null;
        // 执行出队操作
        x=dequeue();
        c=count.getAndDecrement();
        // 如果当前元素不是队列中的唯一一个元素，就协助唤醒消费者
        if(c>1)
        notEmpty.signal();
        }finally{
        takeLock.unlock();
        }
        // 如果出队前，队列是满的，那么出队后，队列不满，唤醒其他生产者
        if(c==capacity)
        signalNotFull();
        return x;
        }
```

如果队列为空，返回null的出队方法.

首先检查数组容量，为空则返回null。之后对读锁进行加锁，再次检查容量.

如果容量不为空，执行核心出队操作。 出队后，如果队列中还有元素，就协助唤醒消费者.

如果出队前，队列是满的，那么当前元素是满的队列出队的第一个元素，唤醒其他生产者.

```java

private E dequeue(){
        // assert takeLock.isHeldByCurrentThread();
        // assert head.item == null
        // 链表的头结点
        Node<E> h=head;
        // 链表的第一个节点
        Node<E> first=h.next;

        h.next=h; // help GC
        // 头结点改成first
        head=first;
        E x=first.item;
        first.item=null;
        // 返回节点
        return x;
        }
```

链表的核心出队方法, 比入队复杂了一点.

将头结点(空的占位节点)指向第一个真实节点，将真实节点的元素返回即可.

##### take() 阻塞

```java

public E take()throws InterruptedException{
final E x;
final int c;
final AtomicInteger count=this.count;
final ReentrantLock takeLock=this.takeLock;
        takeLock.lockInterruptibly();
        try{
        while(count.get()==0){
        notEmpty.await();
        }
        x=dequeue();
        c=count.getAndDecrement();
        if(c>1)
        notEmpty.signal();
        }finally{
        takeLock.unlock();
        }
        if(c==capacity)
        signalNotFull();
        return x;
        }
```

首先加锁，然后判断队列是否为空，如果为空，就在`notEmpty`条件上阻塞，等待唤醒.

被唤醒后，说明当前队列不为空，执行出队操作.

如果出队后，队列不为空，协助唤醒消费者. 如果出队前，队列是满的，那么就唤醒生产者.

##### poll(time,unit)

```java

public E poll(long timeout,TimeUnit unit)throws InterruptedException{
final E x;
final int c;
        long nanos=unit.toNanos(timeout);
final AtomicInteger count=this.count;
final ReentrantLock takeLock=this.takeLock;
        takeLock.lockInterruptibly();
        try{
        while(count.get()==0){
        if(nanos<=0L)
        return null;
        nanos=notEmpty.awaitNanos(nanos);
        }
        x=dequeue();
        c=count.getAndDecrement();
        if(c>1)
        notEmpty.signal();
        }finally{
        takeLock.unlock();
        }
        if(c==capacity)
        signalNotFull();
        return x;
        }

```

和`take`方法很相似，只是在发现队列为空时，需要判断是否超时，如果超时，返回null。如果没有超时，就让当前线程阻塞给定的时间，而不是无限的阻塞.

#### 查看方法

* size 返回当前数量
* remainingCapacity 剩余容量
* peek 获取当前队头元素，但是不弹出，主要用于查看队头元素内容

#### 总结

`LinkedBlockingQueue` 是另外一个比较简单的阻塞队列实现. 内部使用链表来存储元素.

* 首先保存了最大容量与当前容量，用来实现有界队列。
* 其次保存了头结点和尾节点，用来实现链表保存实际的元素,且方便入队与出队操作
* 持有两把锁，分别锁队头和队尾，用来保证线程安全
* 每把锁有对应的等待条件`Condition`，用来休眠/唤醒, 入队和出队的线程，也就是生产者和消费者线程，用来实现线程阻塞及条件满足后的唤醒功能.

由于保存了队头和队尾节点，入队和出队操作的性能都是比较不错的，使用两把锁，分别控制入队和出队的同步控制. 能够最小化锁竞争，提升性能。

与数组实现的`ArrayBlockingQueue`相比，吞吐量会更高一些，但是在高并发的情况下，会有一些不可预测的性能损失.

## SynchronousQueue

### 官方注释翻译

一个阻塞队列的实现，他的插入操作必须等待对应的移除操作. 反之亦然.

一个同步队列没有内部的容量限制.

* 不能执行`peek()`操作，因此只有当你尝试去移除的时候，元素才存在.
* 在没有其他线程等待移除的时候,你不能使用任何方法来插入一个元素.
* 不能执行迭代操作,因为没有任何元素可以迭代.

队头元素是第一个尝试添加元素的写入线程;如果没有等待的写入线程,那么没有任何元素可以用来移除,`poll`方法将会返回null.

如果以一个`集合`的视角来看`SynchronousQueue`,那么它是一个空的集合. 这个队列也不接受null元素.

同步队列像是一个合并的渠道. 一个线程中运行的事物,必须同步等待另外一个线程中运行的事务来处理某些信息,比如事件,任务等等.

这个类支持可选的公平策略.默认情况下,是没有任何保证的. 如果构造函数中,指定了使用公平策略,那么会保证线程访问的顺序是FIFO.

这个类也是Java集合框架的一部分.

### 源码

#### 定义

```java
public class SynchronousQueue<E> extends AbstractQueue<E>
        implements BlockingQueue<E>, java.io.Serializable {
```

继承了`AbstractQueue`和`BlockingQueue`,因此是一个阻塞队列.

#### 属性

```java

// 负责传输的类
private transient volatile Transferer<E> transferer;
// 队列的锁
private ReentrantLock qlock;
// 生产者等待队列
private WaitQueue waitingProducers;
// 消费者的等待队列
private WaitQueue waitingConsumers;
```

一共4个属性，除了一个可重入锁之外， 其他都是内部实现类，依次看一下.

#### Transferer

```java

// 抽象类，定义了传输的行为，他的实现类在下面
abstract static class Transferer<E> {
    abstract E transfer(E e, boolean timed, long nanos);
}
```

##### TransferStack 栈

内部保存了栈的头节点: `head`

```java
volatile SNode head;
```

这个`SNode`也是内部类，比较简单.

```java
static final class SNode {
    volatile SNode next;        // next node in stack
    volatile SNode match;       // the node matched to this
    volatile Thread waiter;     // to control park/unpark
    Object item;                // data; or null for REQUESTs
    int mode;
}
```

保存了当前节点的值，以及下一个节点，还有与当前节点匹配的节点.

同时保存了等待的线程，用于阻塞和唤醒.

`TransferStack`栈对于传输的实现为:

```java
        @SuppressWarnings("unchecked")
        E transfer(E e, boolean timed, long nanos) {
            SNode s = null; // constructed/reused as needed
                // 当前请求的类型是生产者还是消费者
            int mode = (e == null) ? REQUEST : DATA;

            // 自旋
            for (;;) {
                SNode h = head;
                // 如果当前栈为空，或者栈首元素的类型和当前类型一些.
                if (h == null || h.mode == mode) {  // empty or same-mode
                    // 超时了
                    if (timed && nanos <= 0L) {     // can't wait
                        // 头结点已经超时了，弹出该头节点,让下一个节点成为头节点
                        if (h != null && h.isCancelled())
                            casHead(h, h.next);     // pop cancelled node
                        else
                            // 超时了但是头结点为空，或者头结点还没取消，就返回空
                            return null;
                    } else if (casHead(h, s = snode(s, e, h, mode))) {
                        // 更新头结点为当前节点
                        // 之后阻塞等待匹配操作
                        SNode m = awaitFulfill(s, timed, nanos);
                        // 如果返回的m 是头结点，说明取消了，返回null
                        if (m == s) {               // wait was cancelled
                            clean(s);
                            return null;
                        }
                        // 如果头结点不为空， 且下一个节点是s. 
                        if ((h = head) != null && h.next == s)
                            casHead(h, s.next);     // help s's fulfiller
                        // 返回匹配成功的item.
                        return (E) ((mode == REQUEST) ? m.item : s.item);
                    }
                } else if (!isFulfilling(h.mode)) { // try to fulfill 没有正在进行中的匹配.
                    // 查看头结点是否取消
                    if (h.isCancelled())            // already cancelled
                        casHead(h, h.next);         // pop and retry
                    // 将当前节点置为头结点
                    else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {
                        // 等待匹配成功
                        for (;;) { // loop until matched or waiters disappear
                            SNode m = s.next;       // m is s's match
                            if (m == null) {        // all waiters are gone
                                casHead(s, null);   // pop fulfill node
                                s = null;           // use new node next time
                                break;              // restart main loop
                            }
                            SNode mn = m.next;
                            if (m.tryMatch(s)) {
                                casHead(s, mn);     // pop both s and m
                                return (E) ((mode == REQUEST) ? m.item : s.item);
                            } else                  // lost match
                                s.casNext(m, mn);   // help unlink
                        }
                    }
                } else {                            // help a fulfiller
                    // 正在匹配中
                    SNode m = h.next;               // m is h's match
                    if (m == null)                  // waiter is gone
                        casHead(h, null);           // pop fulfilling node
                    else {
                        SNode mn = m.next;
                        if (m.tryMatch(h))          // help match
                            casHead(h, mn);         // pop both h and m
                        else                        // lost match
                            h.casNext(m, mn);       // help unlink
                    }
                }
            }
        }
```

代码比较复杂，尝试写一下各种分支:

1. 栈为空，或者栈首元素和当前的类型一致，要么都是消费者要么都是生产者.
    1. 如果超时了:
        1. 栈首元素已经被取消，就更新栈首元素，重新自旋.
        2. 栈首元素没取消或者为空，直接返回null. 结束.
    2. 没有超时，将当前节点放到栈首成功. 等待匹配. 
        1. 匹配失败，超时了，返回null。
        2. 匹配成功，返回对应的元素.
2. 没有正在进行的匹配.
    1. 如果栈首元素取消了，弹出它，换成他的next继续循环.
    2. 将栈首元素更换为当前元素，且状态为正在匹配，成功.
        1. 自旋等待匹配，匹配成功进行返回，失败继续匹配.
    3. 更新失败，继续循环.
3. 正在进行匹配，协助更新栈首及next指针.


##### TransferQueue 队列

首先是队列中的节点，保存了指向向一个节点的指针，当前节点的元素，以及等待的线程.

```java
//队列中的节点
static final class QNode {
    volatile QNode next;          // next node in queue
    volatile Object item;         // CAS'ed to or from null
    volatile Thread waiter;       // to control park/unpark
    final boolean isData;
}
```

它的属性有:

```java
transient volatile QNode head;
transient volatile QNode tail;
transient volatile QNode cleanMe;
```

队头和队尾。

```java

        @SuppressWarnings("unchecked")
        E transfer(E e, boolean timed, long nanos) {
            QNode s = null; // constructed/reused as needed
            boolean isData = (e != null);

            for (;;) {
                QNode t = tail;
                QNode h = head;
                if (t == null || h == null)         // saw uninitialized value
                    continue;                       // spin

                if (h == t || t.isData == isData) { // empty or same-mode
                    QNode tn = t.next;
                    if (t != tail)                  // inconsistent read
                        continue;
                    if (tn != null) {               // lagging tail
                        advanceTail(t, tn);
                        continue;
                    }
                    if (timed && nanos <= 0L)       // can't wait
                        return null;
                    if (s == null)
                        s = new QNode(e, isData);
                    if (!t.casNext(null, s))        // failed to link in
                        continue;

                    advanceTail(t, s);              // swing tail and wait
                    Object x = awaitFulfill(s, e, timed, nanos);
                    if (x == s) {                   // wait was cancelled
                        clean(t, s);
                        return null;
                    }

                    if (!s.isOffList()) {           // not already unlinked
                        advanceHead(t, s);          // unlink if head
                        if (x != null)              // and forget fields
                            s.item = s;
                        s.waiter = null;
                    }
                    return (x != null) ? (E)x : e;

                } else {                            // complementary-mode
                    QNode m = h.next;               // node to fulfill
                    if (t != tail || m == null || h != head)
                        continue;                   // inconsistent read

                    Object x = m.item;
                    if (isData == (x != null) ||    // m already fulfilled
                        x == m ||                   // m cancelled
                        !m.casItem(x, e)) {         // lost CAS
                        advanceHead(h, m);          // dequeue and retry
                        continue;
                    }

                    advanceHead(h, m);              // successfully fulfilled
                    LockSupport.unpark(m.waiter);
                    return (x != null) ? (E)x : e;
                }
            }
        }

```

队列的匹配操作如上.


仍然是自旋:

1. 如果队列为空，自旋.
2. 如果队列为空，或者都是同一个类型的节点.
    1. 如果队尾发生变化，重新自旋.
    2. 如果队尾向后延长，重新自旋.
    3. 如果超时了，返回null。
    4. 如果当前节点为空，创建当前节点.
    5. 如果将当前节点设置为队尾失败，重新自旋.
    6. 等待匹配，如果匹配失败，返回null。
    7. 匹配成功返回对应的元素.
3. 如果队列不为空，且不是同一个类型的节点
    1. 匹配成功，头结点出队，唤醒等待线程.

这两个实现类有什么区别的？ 就是用来实现公平性的.

#### 构造方法

```java
public SynchronousQueue() {
        this(false);
}

public SynchronousQueue(boolean fair) {
        transferer = fair ? new TransferQueue<E>() : new TransferStack<E>();
}
```

如果是公平性的，则使用FIFO的队列，如果不是公平性的，就使用栈.

#### 入队方法

* put

```java

    public void put(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();
        if (transferer.transfer(e, false, 0) == null) {
            Thread.interrupted();
            throw new InterruptedException();
        }
    }
```

直接调用`transferer`的传输方法，成功则返回，否则就抛出异常.

其他类似.

#### 出队方法

```java

    public E take() throws InterruptedException {
        E e = transferer.transfer(null, false, 0);
        if (e != null)
            return e;
        Thread.interrupted();
        throw new InterruptedException();
    }
```
直接调用`transferer`的传输方法，成功则返回，否则就抛出异常.

其他类似.

#### WaitQueue 等待队列

```java

    @SuppressWarnings("serial")
    static class WaitQueue implements java.io.Serializable { }
    static class LifoWaitQueue extends WaitQueue {
        private static final long serialVersionUID = -3633113410248163686L;
    }
    static class FifoWaitQueue extends WaitQueue {
        private static final long serialVersionUID = -3623113410248163686L;
    }
    private WaitQueue waitingProducers;
    private WaitQueue waitingConsumers;
```

等待队列以及生产者消费者队列两个属性，只是在JDK1.5版本为了方便序列化而加入的没有意义的空类.


#### 总结

`SynchronousQueue`内部根据是否公平性，实现了一个队列一个栈，用来保存当前请求的生产者和消费者.

将生产者和消费者抽象成队列或者栈中的节点，每次请求来到之后，找另外一种类型的节点进行匹配，如果匹配成功，两个节点均出队，如果匹配失败就不断自旋尝试.

## PriorityBlockingQueue 优先级阻塞队列


### 官方注释翻译

一个无界的阻塞队列，使用相同的排队规则`PriorityQueue`并且提供阻塞的操作. 因为这个队列逻辑上是误解的，尝试添加操作可能会失败，由于资环耗尽了(比如OOM).

这个类不接受null元素. 一个优先级队列依赖于自然序并且不保证`non-comparable(不支持比较的元素)`的元素顺序.

这个类和他的迭代器实现了`Collection`和`Iterator`接口所有可选的方法，这个迭代器提供了`iterator()`和`spliterator()`， 不保证遍历元素的顺序.

如果你需要排序的遍历，可以使用`Arrays.sort(pq.toArray())`. 另外，方法`drainTo`可以用来移除一些元素，并且把他们放到另外一个集合中.

这个类的操作，不保证相同优先级的元素的顺序. 如果你需要强制一个顺序，你可以定义定制化的类或者比较器，使用第二个key来打破第一个key相同的情况.

举个例子，这里有一个类提供了`FIFO`顺序去比较元素。

```java
 class FIFOEntry<E extends Comparable<? super E>>
     implements Comparable<FIFOEntry<E>> {
   static final AtomicLong seq = new AtomicLong(0);
   final long seqNum;
   final E entry;
   public FIFOEntry(E entry) {
     seqNum = seq.getAndIncrement();
     this.entry = entry;
   }
   public E getEntry() { return entry; }
    
   public int compareTo(FIFOEntry<E> other) {
       // 首先调用`CompareTo`来获取优先级
     int res = entry.compareTo(other.entry);
     // 如果第一个优先级一样, 就根据seqNum再给定一个优先级.
     if (res == 0 && other.entry != this.entry)
       res = (seqNum < other.seqNum ? -1 : 1);
     return res;
   }
 }
```

实现了`CompareTo`,首先使用原始类的`CompareTo`，如果优先级相等，就是用内部自定义的`seqNum`来比较优先级.

这个类也是java集合框架的一个成员.


### 源码


#### 定义

```java
@SuppressWarnings("unchecked")
public class PriorityBlockingQueue<E> extends AbstractQueue<E>
        implements BlockingQueue<E>, java.io.Serializable {
```

实现了队列的接口以及阻塞队列的接口.

#### 属性

```java

    // 实际保存数据的数组
    private transient Object[] queue;

     // 元素数量
    private transient int size;

     // 比较器，定义了元素的优先级
    private transient Comparator<? super E> comparator;

     // 锁
    private final ReentrantLock lock = new ReentrantLock();

     // 不为空的等待条件
    private final Condition notEmpty = lock.newCondition();

     // 锁
    private transient volatile int allocationSpinLock;

     // 用于帮助序列化的一个类，没啥用
    private PriorityQueue<E> q;
```

使用数组来保存元素，保存了当前的数量，以及一个比较器，用于定义元素之间的优先级.

#### 构造函数

```java

    public PriorityBlockingQueue() {
        this(DEFAULT_INITIAL_CAPACITY, null);
    }
    public PriorityBlockingQueue(int initialCapacity) {
        this(initialCapacity, null);
    }

    public PriorityBlockingQueue(int initialCapacity,
                                 Comparator<? super E> comparator) {
        if (initialCapacity < 1)
            throw new IllegalArgumentException();
        this.comparator = comparator;
        this.queue = new Object[Math.max(1, initialCapacity)];
    }

    public PriorityBlockingQueue(Collection<? extends E> c) {
        boolean heapify = true; // true if not known to be in heap order
        boolean screen = true;  // true if must screen for nulls
        if (c instanceof SortedSet<?>) {
            SortedSet<? extends E> ss = (SortedSet<? extends E>) c;
            this.comparator = (Comparator<? super E>) ss.comparator();
            heapify = false;
        }
        else if (c instanceof PriorityBlockingQueue<?>) {
            PriorityBlockingQueue<? extends E> pq =
                (PriorityBlockingQueue<? extends E>) c;
            this.comparator = (Comparator<? super E>) pq.comparator();
            screen = false;
            if (pq.getClass() == PriorityBlockingQueue.class) // exact match
                heapify = false;
        }
        Object[] es = c.toArray();
        int n = es.length;
        // If c.toArray incorrectly doesn't return Object[], copy it.
        if (es.getClass() != Object[].class)
            es = Arrays.copyOf(es, n, Object[].class);
        if (screen && (n == 1 || this.comparator != null)) {
            for (Object e : es)
                if (e == null)
                    throw new NullPointerException();
        }
        this.queue = ensureNonEmpty(es);
        this.size = n;
        if (heapify)
            heapify();
    }

```

实现了四个构造方法，前三个都是对初始容量及比较器的赋值. 第四个构造函数支持将给定集合中的元素初始化到队列中.


#### 入队操作
```java

    public boolean add(E e) {
        return offer(e);
    }

    public boolean offer(E e) {
        if (e == null)
            throw new NullPointerException();
        // 加锁
        final ReentrantLock lock = this.lock;
        lock.lock();
        int n, cap;
        Object[] es;
        // 扩容
        while ((n = size) >= (cap = (es = queue).length))
            tryGrow(es, cap);
        try {
            // 根据是否有特定的比较器，将当前元素上浮到正确的优先级位置.
            final Comparator<? super E> cmp;
            if ((cmp = comparator) == null)
                siftUpComparable(n, e, es);
            else
                siftUpUsingComparator(n, e, es, cmp);
            // 数量+1,通知不为空的等待线程
            size = n + 1;
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
        return true;
    }

    public void put(E e) {
        offer(e); // never need to block
    }

    public boolean offer(E e, long timeout, TimeUnit unit) {
        return offer(e); // never need to block
    }
```

`add, offer, put, offer(time,unit)`四个方法，本质上都是调用的同一个`offer`，为啥呢?

因为这个优先级队列，本质上是无界的，也就是说，没有`队列满了`的情况，因此前面的等待条件，只有`notEmpty`而没有和其他队列一样的`notFull`。

这个方法比较简单:

1. 如果容量不够扩容
2. 直接放进队列中，然后根据是否有特定的比较其，进行上浮，一直到自己的优先级应该在的位置
3. 通知所有等待队列不为空的线程即可.

两个上浮操作:

```java

    private static <T> void siftUpComparable(int k, T x, Object[] es) {
        Comparable<? super T> key = (Comparable<? super T>) x;
        // 遍历
        while (k > 0) {
            // 父节点
            int parent = (k - 1) >>> 1;
            Object e = es[parent];
            // 父节点和当前节点对比
            if (key.compareTo((T) e) >= 0)
                break;
            es[k] = e;
            k = parent;
        }
        // 找到的位置给新的节点
        es[k] = key;
    }

    // 和上面的方法一样，只不过比较器是给定的，不是用元素本身的CompareTo。
    private static <T> void siftUpUsingComparator(
        int k, T x, Object[] es, Comparator<? super T> cmp) {
        while (k > 0) {
            int parent = (k - 1) >>> 1;
            Object e = es[parent];
            if (cmp.compare(x, (T) e) >= 0)
                break;
            es[k] = e;
            k = parent;
        }
        es[k] = x;
    }
```

因为队列中的元素，其实是一个平衡的二叉堆，因此在给定的元素，寻找优先级所在的位置时， 使用类似于堆的上浮操作即可.


#### 出队操作

```java

    // 如果为空，返回null
    public E poll() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return dequeue();
        } finally {
            lock.unlock();
        }
    }

    public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        E result;
        try {
            while ( (result = dequeue()) == null)
                notEmpty.await();
        } finally {
            lock.unlock();
        }
        return result;
    }

    public E poll(long timeout, TimeUnit unit) throws InterruptedException {
        long nanos = unit.toNanos(timeout);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        E result;
        try {
            while ( (result = dequeue()) == null && nanos > 0)
                nanos = notEmpty.awaitNanos(nanos);
        } finally {
            lock.unlock();
        }
        return result;
    }
```

队列的几个出队方法，核心都是调用`dequeue()`方法，只是在获取元素为空时，处理策略不一致.

* poll 返回null
* take 永久阻塞
* poll(time,unit) 阻塞给定时间.


核心的出队方法如下:

```java

    private E dequeue() {
        // assert lock.isHeldByCurrentThread();
        final Object[] es;
        final E result;

        // 获取数组第一个，也就是堆顶的元素
        if ((result = (E) ((es = queue)[0])) != null) {
            final int n;
            // 最后一个元素
            final E x = (E) es[(n = --size)];
            es[n] = null;
            if (n > 0) {
                // 将他放在堆顶，然后下沉，使堆符合优先级
                final Comparator<? super E> cmp;
                if ((cmp = comparator) == null)
                    siftDownComparable(0, x, es, n);
                else
                    siftDownUsingComparator(0, x, es, n, cmp);
            }
        }
        return result;
    }
```

也算是常见的堆的出堆代码了，首先获取堆顶元素，之后将堆的最后一个元素，放在堆顶，进行下沉，使整个堆符合优先级.

下沉代码:

```java

    private static <T> void siftDownComparable(int k, T x, Object[] es, int n) {
        // assert n > 0;
        Comparable<? super T> key = (Comparable<? super T>)x;
        int half = n >>> 1;           // loop while a non-leaf
        while (k < half) {
            // 堆顶元素的孩子节点
            int child = (k << 1) + 1; // assume left child is least
            Object c = es[child];
            int right = child + 1;
            if (right < n &&
                ((Comparable<? super T>) c).compareTo((T) es[right]) > 0)
                c = es[child = right];
            if (key.compareTo((T) c) <= 0)
                break;
            es[k] = c;
            k = child;
        }
        es[k] = key;
    }

```

将给定节点与右边子节点进行比较，如果不符合优先级，交换位置. 递归执行.

#### 总结


一个带有优先级的阻塞队列. 支持使用元素本身的`CompareTo`以及给定比较器`Comparator`.

优先级的实现，使用堆. 因此内部保存元素的载体是一个数组. 

由于设计是无界的队列，因此入队方法永远不会阻塞，只会逐渐撑爆内存. `put`方法不会阻塞. 出队方法像其他阻塞队列一样，会阻塞.

对数组的读写使用`ReentrantLock`来保证线程安全性. 

阻塞操作使用`Condition`来实现阻塞等待与唤醒.

## DelayQueue 延迟队列


### 官方注释翻译

用于延迟元素的一个无界的阻塞队列实现. 延迟元素只有在他的延迟过期之后，才可以被获取.

队头的元素，是队列中过期最早的元素。如果没有元素过期，那么将没有队头元素，`poll`方法将会返回一个null.

过期操作只有元素的`getDelay`方法返回一个小于等于0的数值时才会起作用.

尽管没有过期的元素，不能通过`take`或者`poll`来获取, 其他方面和正常的元素是一样的.

比如，`size()`返回过期和未过期的元素的计数，同时，这个队列也是不接受空元素.

这个类和他的迭代器实现了`Collection`和`Iterator`接口的所有可选方法.

这个类也是Java集合框架的一部分噢。

### 源码

#### 定义

```java

public class DelayQueue<E extends Delayed> extends AbstractQueue<E>
implements BlockingQueue<E> {

```
首先是一个普通队列， 且还是阻塞队列. 拥有他们的所有属性，同时，还要求放入的元素，是实现了`Delayed`接口的. 该接口定义如下:

```java

public interface Delayed extends Comparable<Delayed> {

    /**
     * Returns the remaining delay associated with this object, in the
     * given time unit.
     *
     * @param unit the time unit
     * @return the remaining delay; zero or negative values indicate
     * that the delay has already elapsed
     */
    long getDelay(TimeUnit unit);
}
```

根据给定的时间单位，返回剩余的延迟时间.

#### 属性

```java

    // 锁
    private final transient ReentrantLock lock = new ReentrantLock();
    // 优先级队列
    private final PriorityQueue<E> q = new PriorityQueue<E>();

    // 正在等待队头元素的线程
    private Thread leader;

    // 有元素可用的等待条件
    private final Condition available = lock.newCondition();
```


使用优先级队列来保存元素，同时记录等待队首元素的线程. 

这个优先级队列，是`java.util`包里的，暂不做详细解释，相信大家都懂哈.

提供了等待条件`available`来负责阻塞线程与唤醒.

#### 构造方法

```java
    public DelayQueue() {}

    public DelayQueue(Collection<? extends E> c) {
        this.addAll(c);
    }

```

提供两个构造方法，分别构造一个空的延迟队列和一个加载给定集合的阻塞队列.

#### 入队系列

```java

    public boolean add(E e) {
        return offer(e);
    }

    public boolean offer(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            // 插入元素
            q.offer(e);
            // 队头元素是刚才插入的元素，说明有可用元素，唤醒等待线程们
            if (q.peek() == e) {
                leader = null;
                available.signal();
            }
            return true;
        } finally {
            lock.unlock();
        }
    }

    public void put(E e) {
        offer(e);
    }

    public boolean offer(E e, long timeout, TimeUnit unit) {
        return offer(e);
    }
```

4个入队系列的方法，本质上都是调用了`offer`. 直接调用内部`优先级队列`的offer，无脑写入即可.

可以看到，该方法永远返回ture. 因为这个延迟队列也是无界的，因此不需要阻塞，不会插入失败.

插入只有两种可能:

1. 成功
2. 内存爆了，程序死掉.

#### 出队系列

##### poll 没有元素返回Null

```java

    public E poll() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            // 获取第一个元素
            E first = q.peek();
            // 第一个元素为空，或者第一个元素的延迟时间没有到期，返回null.
            // 否则返回该元素
            return (first == null || first.getDelay(NANOSECONDS) > 0)
                ? null
                : q.poll();
        } finally {
            lock.unlock();
        }
    }
```

首先查看第一个元素，如果不为空且已经过期了，那就弹出进行返回. 否则就返回null.


##### take 阻塞等待

```java

    public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            // 自旋
            for (;;) {
                //  查看第一个元素
                E first = q.peek();
                // 第一个元素为空，直接等待
                if (first == null)
                    available.await();
                else {
                    // 第一个元素已经超时，可用了，就进行弹出
                    long delay = first.getDelay(NANOSECONDS);
                    if (delay <= 0L)
                        return q.poll();
                    // 等待
                    first = null; // don't retain ref while waiting
                    if (leader != null)
                        available.await();
                    else {
                        // 如果当前是第一个等待队首元素的线程,记录一下当前线程，且只阻塞剩余的时间，就苏醒来检查一下是否可用了
                        Thread thisThread = Thread.currentThread();
                        leader = thisThread;
                        try {
                            available.awaitNanos(delay);
                        } finally {
                            if (leader == thisThread)
                                leader = null;
                        }
                    }
                }
            }
        } finally {
            // 拿到元素后，协助唤醒一下等待线程
            if (leader == null && q.peek() != null)
                available.signal();
            lock.unlock();
        }
    }
```

这个阻塞版本的获取元素复杂一点.

1. 如果第一个元素为空， 就让当前线程阻塞等待.
2. 不为空，且已经过期，直接弹出，进行返回，此时获取元素成功.
3. 不为空，且没有过期，如果当前线程，是第一个等待队首元素的线程, 就阻塞第一个元素剩余的延迟时间, 到期后苏醒来检查队首元素的状态.
4. 不是第一个等待的线程，直接阻塞，等待第一个线程来唤醒.
5. 获取元素成功后，如果还有可用元素，协助唤醒一下其余的等待线程.

##### poll(time,unit) 超时阻塞版本

和上面的`take`代码很像，只是在每一个线程的阻塞时都加上了时间限制，就不重复讲了.

#### 查看系列


##### size 查看元素数量

这个简单的方法为啥要写呢，因为要注意: **返回的size,是所有过期的，未过期的总数**.

```java

    public int size() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return q.size();
        } finally {
            lock.unlock();
        }
    }
```

直接调用了内部的优先级队列的`size()`方法，没有判断是否过期.

##### peek() 查看队首元素，不弹出

由于在延迟队列中，总是需要看一下，队首元素，如果已经过期，就弹出，没过期，就不处理. 因此也简单看一下`peek()`方法.

```java

    public E peek() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return q.peek();
        } finally {
            lock.unlock();
        }
    }
```

没啥，加锁，然后调用优先级队列的`peek`完事了。

#### 总结

延迟队列，本质上是一个带有优先级的阻塞队列，且根据延迟限制队首元素的出队.

* 优先级队列的实验，使用了`java.util.PriorityQueue`,本质上实现应该也是一个堆实现的.
* 阻塞队列的实现，使用`Condition`条件. 由于是无界队列，入队操作不会阻塞. 出队行为在条件上等待，当有符合条件的元素时，唤醒所有等待线程.
* 延迟属性的实现，在出队时，对队首元素进行额外的过期判断，如果过期，就弹出，没有过期，就返回null.
* 线程安全方面，由于`java.util.PriorityQueue`不是线程安全的，因此使用额外的一个`ReentrantLock`来限制对数据的读写访问.

<br>

## LinkedBlockingDeque 链表双端阻塞队列

### 官方注释翻译


一个可选是否有界的双端阻断队列. 使用链表实现.

可选的容量边界，使用构造函数来初始化，可以防止超出范围的扩容操作. 如果容量没有特殊指定的话，是`Integer.MAX_VALUE`.

链表的节点根据每一个插入操作，动态的进行创建，除非超过了给定的边界.

大部分操作的时间负责度都是线性的. 另外的有: `remove,removeFirstOccurrence`等一些移除方法和`contains`方法.

这个类和他的迭代器，实现了`Collection`和`Iterator`接口的所有可选方法.

### 源码

#### 定义

```java

public class LinkedBlockingDeque<E>
    extends AbstractQueue<E>
    implements BlockingDeque<E>, java.io.Serializable {
```

一个双端队列～.

#### 链表节点 Node

```java

    static final class Node<E> {
        /**
         * The item, or null if this node has been removed.
         */
        E item;

        /**
         * One of:
         * - the real predecessor Node
         * - this Node, meaning the predecessor is tail
         * - null, meaning there is no predecessor
         */
        Node<E> prev;

        /**
         * One of:
         * - the real successor Node
         * - this Node, meaning the successor is head
         * - null, meaning there is no successor
         */
        Node<E> next;

        Node(E x) {
            item = x;
        }
    }
```

比较粗暴，保存了当前节点的实际元素，以及指向前后节点的指针.

#### 属性

```java
    transient Node<E> first;

    /**
     * Pointer to last node.
     * Invariant: (first == null && last == null) ||
     *            (last.next == null && last.item != null)
     */
    transient Node<E> last;

    /** Number of items in the deque */
    private transient int count;

    /** Maximum number of items in the deque */
    private final int capacity;

    /** Main lock guarding all access */
    final ReentrantLock lock = new ReentrantLock();

    /** Condition for waiting takes */
    private final Condition notEmpty = lock.newCondition();

    /** Condition for waiting puts */
    private final Condition notFull = lock.newCondition();

```


* 保存了队列的头结点和尾节点，用来实现双端的列表
* 保存了当前数量和最大容量，用来实现有界队列
* lock用来对队列进行同步控制
* `notEmpty`和`notFull`两个条件用来进行阻塞和唤醒线程.


#### 构造方法

```java

    public LinkedBlockingDeque() {
        this(Integer.MAX_VALUE);
    }

    public LinkedBlockingDeque(int capacity) {
        if (capacity <= 0) throw new IllegalArgumentException();
        this.capacity = capacity;
    }

    public LinkedBlockingDeque(Collection<? extends E> c) {
        this(Integer.MAX_VALUE);
        addAll(c);
    }
```

对最大容量进行初始化.

同时还支持将给定集合的所有元素进行初始化入队操作.

#### 入队操作

* addFirst
* addLast
* offerFirst
* offerLast
* putFirst
* putLast
* offerFirst
* offerLast

8个方法，分别对应队头和队尾的4种插入方法.

##### add 抛出异常

```java

    public void addFirst(E e) {
        if (!offerFirst(e))
            throw new IllegalStateException("Deque full");
    }

    public void addLast(E e) {
        if (!offerLast(e))
            throw new IllegalStateException("Deque full");
    }

```

调用插入方法，如果失败，直接抛出异常.


##### offer(e) 返回特殊值

```java

    public boolean offerFirst(E e) {
        if (e == null) throw new NullPointerException();
        Node<E> node = new Node<E>(e);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return linkFirst(node);
        } finally {
            lock.unlock();
        }
    }

    /**
     * @throws NullPointerException {@inheritDoc}
     */
    public boolean offerLast(E e) {
        if (e == null) throw new NullPointerException();
        Node<E> node = new Node<E>(e);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return linkLast(node);
        } finally {
            lock.unlock();
        }
    }
```

首先使用内部的锁进行加锁后，分别将给定节点链接在头部和尾部.

```java

    // 链接在头部
    private boolean linkFirst(Node<E> node) {
        // assert lock.isHeldByCurrentThread();
        // 容量超出，返回false
        if (count >= capacity)
            return false;
        // 第一个节点
        Node<E> f = first;
        // 当前节点成为头结点
        node.next = f;
        first = node;
        if (last == null)
            last = node;
        else
            f.prev = node;
        // 唤醒消费者
        ++count;
        notEmpty.signal();
        return true;
    }

    /**
     * Links node as last element, or returns false if full.
     */
    private boolean linkLast(Node<E> node) {
        // assert lock.isHeldByCurrentThread();
            // 判断容量
        if (count >= capacity)
            return false;
        // 将当前节点链接在尾部
        Node<E> l = last;
        node.prev = l;
        last = node;
        if (first == null)
            first = node;
        else
            l.next = node;
        // 唤醒消费者
        ++count;
        notEmpty.signal();
        return true;
    }
```

##### put 阻塞

```java

    public void putFirst(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();
        Node<E> node = new Node<E>(e);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            while (!linkFirst(node))
                notFull.await();
        } finally {
            lock.unlock();
        }
    }

    /**
     * @throws NullPointerException {@inheritDoc}
     * @throws InterruptedException {@inheritDoc}
     */
    public void putLast(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();
        Node<E> node = new Node<E>(e);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            while (!linkLast(node))
                notFull.await();
        } finally {
            lock.unlock();
        }
    }
```

和offer方法很相似，只是在链接失败时，也就是队列满的时候，在`notFull`条件上阻塞等待。


##### offer(e,time,unit) 超时阻塞

和put很相似，只是阻塞不是永久的，而是阻塞给定的毫秒数而已。不再重复。


#### 出队操作

* removeFirst
* removeLast
* pollFirst
* pollLast
* takeFirst
* takeLast
* pollFirst
* pollLast

八个方法，分别对应队头和队尾的4种移除操作.

##### remove 抛出异常

```java

    public E removeFirst() {
        E x = pollFirst();
        if (x == null) throw new NoSuchElementException();
        return x;
    }


    public E removeLast() {
        E x = pollLast();
        if (x == null) throw new NoSuchElementException();
        return x;
    }
```

分别弹出头结点和尾节点，如果为空，则抛出异常.


##### poll 返回特殊值

```java

    public E pollFirst() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return unlinkFirst();
        } finally {
            lock.unlock();
        }
    }

    public E pollLast() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return unlinkLast();
        } finally {
            lock.unlock();
        }
    }
```

直接调用核心的解除链接，弹出方法. 为空时直接返回null.


```java

    private E unlinkFirst() {
        // assert lock.isHeldByCurrentThread();
            // 如果队首为空，返回空
        Node<E> f = first;
        if (f == null)
            return null;
        // 将第二个元素放到队首，返回当前的队首元素
        Node<E> n = f.next;
        E item = f.item;
        f.item = null;
        f.next = f; // help GC
        first = n;
        if (n == null)
            last = null;
        else
            n.prev = null;
        --count;
        // 唤醒生产者
        notFull.signal();
        return item;
    }

    /**
     * Removes and returns last element, or null if empty.
     */
    private E unlinkLast() {
        // assert lock.isHeldByCurrentThread();
        Node<E> l = last;
        if (l == null)
            return null;
        Node<E> p = l.prev;
        E item = l.item;
        l.item = null;
        l.prev = l; // help GC
        last = p;
        if (p == null)
            first = null;
        else
            p.next = null;
        --count;
        notFull.signal();
        return item;
    }

```

分别解除队首和队尾元素，将他们的下一个作为新的队首和队尾.


##### take 阻塞

```java

    public E takeFirst() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            E x;
            // 如果弹出元素是空，就阻塞等待
            while ( (x = unlinkFirst()) == null)
                notEmpty.await();
            return x;
        } finally {
            lock.unlock();
        }
    }

    public E takeLast() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            E x;
            while ( (x = unlinkLast()) == null)
                notEmpty.await();
            return x;
        } finally {
            lock.unlock();
        }
    }
```

首先分别弹出队首和队尾的元素，如果为空，就在`notEmpty`条件上阻塞等待.

##### poll(e,time,unit)

和`take`很相似，不再重复.


#### 双端队列提供FIFO的队列接口

上面的方法都是针对双端队列的，指定此次操作是队头还是队尾，而双端队列也是直接提供队列的方法的.


```java

    public boolean add(E e) {
        addLast(e);
        return true;
    }

    public boolean offer(E e) {
        return offerLast(e);
    }

    public void put(E e) throws InterruptedException {
        putLast(e);
    }

    public boolean offer(E e, long timeout, TimeUnit unit)
        throws InterruptedException {
        return offerLast(e, timeout, unit);
    }

    public E remove() {
        return removeFirst();
    }

    public E poll() {
        return pollFirst();
    }

    public E take() throws InterruptedException {
        return takeFirst();
    }

    public E poll(long timeout, TimeUnit unit) throws InterruptedException {
        return pollFirst(timeout, unit);
    }
    
```

可以看到，对于普通的队列方法，入队调用`Last`相关， 也就是队尾添加. 出队方法调用`First`相关，也就是队首出队.

因此双端队列可以当做一个`FIFO`的普通队列来使用.


#### 总结


和`LinkedBlockingQueue`很相似，只是提供了双端的接口而已.

* 内部使用链表来存储元素，而且是双端链表，因此保存了队首指针和队尾指针
* 使用`ReentrantLock`来保证内部节点读写之间的同步
* 使用等待条件`notFull`和`notEmpty`来控制生产者和消费者的阻塞与唤醒.
* 支持指定最大容量，当要添加的元素超过了最大容量时，会根据情况进行抛出异常或者阻塞等操作.



## 阻塞队列的最后一个 LinkedTransferQueue

完。
<br>
<br>
<br>

## 联系我

最后，欢迎关注我的个人公众号【 呼延十 】，会不定期更新很多后端工程师的学习笔记。 也欢迎直接公众号私信或者邮箱联系我，一定知无不言，言无不尽。
![](http://img.couplecoders.tech/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png)


<br>
<br>




**以上皆为个人所思所得，如有错误欢迎评论区指正。**

**欢迎转载，烦请署名并保留原文链接。**

**联系邮箱：huyanshi2580@gmail.com**

**更多学习笔记见个人博客或关注微信公众号 &lt;呼延十 &gt;------><a href="{{ site.baseurl }}/">呼延十</a>**