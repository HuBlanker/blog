---
layout: post
category: [算法]
tags:
  - 算法
---


最近稍微闲了点, 继续学习. 先开个二分法练练手.再去学Lucene.

# 模板

二分法, 简单又复杂. 原理大家基本上清楚. 不在赘述.

二分是可以有模板的. 我们按照模板来解题,逐步总结一些小细节.

```python
def binary_search(nums, target):
    l = 0
    r = len(nums) - 1 # right
    while l < r: # 循环条件
        m = l + ((r - l) >> 1) # 求取中值
        if target == nums[m]:
            # 相等
        elif target < nums[m]:
            # 小于
        elif target > nums[m]:
            # 大于
    return nums[l]
```

几个关键点:

* 搜索区间的选取
* 循环条件
* 中间值的求取
* 左右边界更新
* 返回值

# 最基础的二分查找

最基础的题型. leetcode第704题. [二分查找](https://leetcode-cn.com/problems/binary-search/)

```python
    def searc(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1
        while left <= right:
            pivot = left + ((right - left) >> 1)
            mid_v = nums[pivot]
            if target == mid_v:
                return pivot
            elif target < mid_v:
                right = pivot - 1
            elif target > mid_v:
                left = pivot + 1
        return -1

```

针对上面的几个关键点. 看一下我们做了什么:


* 搜索区间的选取:

  left = 0, right = len(nums) - 1. 也就是说, 我们选取了`[0, length-1]`的闭合区间进行搜索. 能改吗? 当然, 但是我不想改.
* 结束条件

  结束条件两个: 

    1. 找到目标值了. 直接返回
    2. 找不到目标值,跳出循环. 我们是闭合区间.假设最终搜索到了 `[3,3]`,此时应该搜索还是跳出? 闭合区间,还有个3没有进行搜索,因此应该继续搜索,知道[4,3] 才是空区间. 所以对应的循环条件是: ` left <= right`.

* 中间值的求取

    常见求法, 注意下溢出问题即可.
* 左边界更新 

    当目标值,大于中间值.也就是说, 我们要取右半边的区间进行搜索. 由于mid已经比较过了,不需要了. 因此取`[mid + 1, right]`. 也就是` left = mid + 1`.
* 右边界更新
    同理,要减一.
* 返回值
    如果找到目标值，返回.
    如果跳出循环,还没找到, 返回-1.

有问题了, 我比较皮,在第一步`right = len(nums) - 1` 的时候, 我不想减1. 可以不?

当然可以. 那就是选择了左闭右开的区间进行搜索. 对应的还要调整循环条件. ` [3, 3)` 已经是一个空区间了.因此可以直接结束, 对应的循环条件改为:`left < right `即可. 如果不修改呢? 在空区间内, 死循环呗, 找不到值.左右边界也不变, 死循环.

# 寻找可重复数组中最左侧的值

这是很常见的一个变种. 数组仍然是排序的升序数组，但是可重复，需要找到最左的目标值的下标.

要求: 如果有，找到最左侧的下标. 如果没有返回-1.

```python
def binary_search_left(nums, target):
    """
    :type nums: List[int]
    :rtype: int
    """
    l = 0
    r = len(nums)
    while l < r:
        m = l + ((r - l) >> 1)
        if target == nums[m]:
            r = m
        elif target < nums[m]:
            r = m
        elif target > nums[m]:
            l = m + 1
    if l == len(nums):
        return -1
    if nums[l] == target:
        return l
    return -1
```

我的思路(基于普通二分):

1. 要找最左侧的值，那么当查找到目标值时，不能直接返回. 要当做: **当前值大于目标值** 来处理.
2. 为了提防上一步处理时,已经找到了最左侧的值，但是 由于`r = m-1`操作，直接扔出了区间之外，因此`r=m`. 每次保留上次比较的值.
3. 由于`r=m`, 因此按照之前的分析，结束条件应该是`l == r`. 也就是说循环条件是: `l < r`. 对应的扫描区间是左闭右开. 


# 寻找可重复数组中最右侧的值





# 其他变种


## 寻找插入位置

leetcode 第35题. [搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

```python
    def searchInsert(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        left = 0
        right = len(nums) - 1
        while left <= right:
            pivot = left + ((right - left) >> 1)
            mid_v = nums[pivot]
            if target == mid_v:
                return pivot
            elif target < mid_v:
                right = pivot - 1
            elif target > mid_v:
                left = pivot + 1
        return left

```

首先按照写一个标准的二分. 如果命中了,就返回下标.

如果没有搜索到. 返回什么呢?

搜索结束时. 区间为: `[a+1, a]`. 此时`a+1`就是因为`a`小于目标值.才进行的+1操作. 因此直接返回`left=a+1`即可.


## 



## 参考文章


<br>


完。
<br>
<br>
<br>


## 联系我
最后，欢迎关注我的个人公众号【 呼延十 】，会不定期更新很多后端工程师的学习笔记。
也欢迎直接公众号私信或者邮箱联系我，一定知无不言，言无不尽。
![](http://img.couplecoders.tech/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png)


<br>
<br>




**以上皆为个人所思所得，如有错误欢迎评论区指正。**


**欢迎转载，烦请署名并保留原文链接。**


**联系邮箱：huyanshi2580@gmail.com**


**更多学习笔记见个人博客或关注微信公众号 &lt;呼延十 &gt;------><a href="{{ site.baseurl }}/">呼延十</a>**