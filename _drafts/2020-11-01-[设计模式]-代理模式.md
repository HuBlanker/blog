---
layout: post
category: [Java, 设计模式]
tags:
  - Java
  - 设计模式
---

## 前言

之前的设计模式文章, 都是因为读书而做笔记写的, 这次的代理模式, 是真正的需求驱动学习, 学习驱动文章了....

其实动态代理及cglib动态代理的大名, 很早就听说过了, 作为面试必备问题, 从校招时候就经常听到, 但是这个名字太唬人了, 且原来一直没有遇到应用场景, 因此也就懒着一直没有学习. 

这次遇到了应用场景, 简单学习之后进行了应用的开发, 闲下来之后当然是要追根究底并且进行一番性能测试了.

## 实际场景

首先来简单的介绍一下这次应用到的场景:

首先我有一个实现了很多方法的类, 每一个方法都是一个对外提供的接口. 如下:

```java
/**
 * @author pfliu
 * @date 2020/11/01.
 * @brief 服务主类
 */
public class MyService implements ServiceInterface {

    @Override
    public void doSomething1() {
        System.out.println("doSomething1");

    }

    @Override
    public int getSomeThing1(String name) {
        System.out.println("getSomeThing1" + "\t" + name);
        return 0;
    }
}

```

客户端调用代码如下:

```java 
/**
 * @author pfliu
 * @date 2020/11/01.
 * @brief 服务主类
 */
public class MyService implements ServiceInterface {

    private ThreadLocal<List<Object>> context = ThreadLocal.withInitial(ArrayList::new);

    @Override
    public void doSomething1() {
        context.get().clear();
        context.get().add(System.currentTimeMillis());
        System.out.println("doSomething1");

    }

    @Override
    public int getSomeThing1(String name) {
        context.get().clear();
        context.get().add(name);
        context.get().add(System.currentTimeMillis());
        System.out.println("getSomeThing1" + "\t" + name);
        return 0;
    }
}
```

此时我要接入一个监控系统, 需要在每一次请求处理之前, 向ThreadLocal中写入一些数据, 代码就变成了这样:

```java
/**
 * @author pfliu
 * @date 2020/11/01.
 * @brief 服务主类
 */
public class MyService implements ServiceInterface {

    private ThreadLocal<List<Object>> context = ThreadLocal.withInitial(ArrayList::new);

    @Override
    public void doSomething1() {
        context.get().clear();
        context.get().add(System.currentTimeMillis());
        System.out.println("doSomething1");

    }

    @Override
    public int getSomeThing1(String name) {
        context.get().clear();
        context.get().add(name);
        context.get().add(System.currentTimeMillis());
        System.out.println("getSomeThing1" + "\t" + name);
        return 0;
    }
}
```

我在每次请求之前, 记录了当前请求的实际参数及请求时间戳. 这样子代码也太难看了吧. 两个方法都这么难看了, 我50多个方法的类, 写出来岂不是要气死同事.

此时就想到了用代理模式来进行代码的优化, 同时后续如果有更多的事情需要在每次请求前来做, 修改代码也会更加舒适一点.


### 静态代理

静态代理, 其实就是写一个新的代理类, 然后实现同样的接口, 持有我们目标类的引用, 每次请求到来之后, 做完想要的工作, 再请求真正的目标类.

简单的改造之后, 变成了如下的样子:

```java
/**
 * @author pfliu
 * @date 2020/11/01.
 * @brief
 */
public class StaticProxy implements ServiceInterface {

    private final MyService myService;
    private final ThreadLocal<List<Object>> context;

    public StaticProxy(MyService myService, ThreadLocal<List<Object>> context) {
        this.myService = myService;
        this.context = context;
    }


    @Override
    public void doSomething1() {
        this.context.get().clear();
        this.context.get().add(System.currentTimeMillis());
        this.myService.doSomething1();
    }

    @Override
    public int getSomeThing1(String name) {
        this.context.get().clear();
        this.context.get().add(name);
        this.context.get().add(System.currentTimeMillis());
        return this.myService.getSomeThing1(name);
    }
}
```

此时客户端就不用持有MyService的实例了, 持有StaticProxy即可.

```java
    public static void main(String[] args) {
        ServiceInterface server = new MyService();
        StaticProxy proxy = new StaticProxy(server, new ThreadLocal<List<Object>>());
        proxy.doSomething1();
        proxy.getSomeThing1("huyanshi");
    }
```

这.....根本就是换汤不换药啊, 原来我要写一个恶心的类, 现在要写一个恶心的类＋一个正常的服务类, 区别也不是很大啊, 当我需要修改写入threadlocal的内容时, 几十个接口仍然是需要一个一个改过去啊.

照例分析下静态代理的优劣势:

优点: 
- 实现简单, 直接重新写写个类.
- 性能没啥损失, 源码编译的,多走一层调用而已.

缺点:
- 代码太过于冗余.
- 不易扩展, 当接口新增一个方法, 我们要修改目标类本身和代理类.

### 动态代理


JDK自带了代理模式, 提供了一个动态代理给我们, 让我们来试试.





## 参考文章


<br>


完。
<br>
<br>
<br>


## 联系我
最后，欢迎关注我的个人公众号【 呼延十 】，会不定期更新很多后端工程师的学习笔记。
也欢迎直接公众号私信或者邮箱联系我，一定知无不言，言无不尽。
![](http://img.couplecoders.tech/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png)


<br>
<br>




**以上皆为个人所思所得，如有错误欢迎评论区指正。**


**欢迎转载，烦请署名并保留原文链接。**


**联系邮箱：huyanshi2580@gmail.com**


**更多学习笔记见个人博客或关注微信公众号 &lt;呼延十 &gt;------><a href="{{ site.baseurl }}/">呼延十</a>**