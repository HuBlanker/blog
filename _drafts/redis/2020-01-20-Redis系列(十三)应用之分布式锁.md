---
layout: post
category: [Redis]
tags:
  - Redis
---





## 前言

有Redis的面试恐怕没有不问分布式锁的吧...

分布式锁有着多种多样的实现方式,今天就来介绍一下 如何用Redis实现一个分布式锁.

## 定义

首先, 什么是分布式锁呢? 先上维基百科的定义:

> 分布式锁，是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。

通俗的理解就是, 在本地应用中, 当我们多个线程需要并发的访问某一个资源时, 我们直接使用本地的锁, 比如Java的synchronized和ReentrantLock.

但是当我们的系统是分布式系统, 竞争资源的是不同进程里的不同线程, 本地锁就没有用了. 此时就需要分布式锁.

举个简单的例子, 你有一个程序, 需要在某天中午进行抽奖, 从所有符合条件的用户中随机挑选出10个人, 将他们的ID记录到MySQL中去. 这很好实现. 但是如果你的服务在线上部署了多个实例, 那么他们每一个实例都会运行这段代码, 每个实例会随机挑出10个人, 这明显是不符合需求的. 

此时就应该使用分布式锁, 让所有的实例竞争, 只有一个实例可以成功拿到锁, 然后进行抽奖操作即可.

分布式锁的实现各种各样, 用MySQL, Redis, zookeeper等等都可以实现, 本文介绍一下如何使用Redis来实现一个分布式锁.

后文举例时都以抽奖为例.

## 实现思路

**简单思路**

首先, 我们理解了分布式锁只是要在 `一个独立于分布式系统的地方树立标志`, 然后保证这个标志就有一个人可以用即可.

那么直接在Redis中设置一个字符串即可.比如我们可以设置 `lock_key`就是代表我们的分布式锁.

当需要获取锁时, 首先调用`exists` 命令判断该key是否存在.

* 存在, 说明有其他进程获取了锁, 当前进程放弃或者重试. 在抽奖场景下, 当前进程直接放弃就好.
* 不存在. 调用`set`命令, 随便写入一个值, 代表自己获取到了锁, 然后进行业务操作, 在完成业务操作之后, 调用`del`命令删除掉该key.

看起来很简单,几行代码就写完了. 伪代码总结如下:

```shell
# 获取锁
exists lock_key
if true:
    放弃
if false:
    set lock_key 1

# 释放锁
del lock_key
```

但是这样做是有极大的缺陷的,如果在生产环境这么操作, 那么应该会 <font color="red">死的很惨</font>. 我们一步一步梳理.

**原子性**

获取锁需要两个步骤, 也就是判断锁是否存在以及实际的获取锁. 这两个步骤是单独的两个命令, 并不能保证原子性.

 假设进程A在判断lock是否存在之后, 线程B又对他进行了操作. 然后线程A再来继续进行操作, 这样明显是错误的, 可能造成重复加锁,或者锁状态判断错误.

 幸好Redis提供了`setnx`指令, 可以先解决这个问题.

 `setnx key value`, 是`set if not exists`的意思, 如果当前key存在, 则不作任何操作并且返回0, 如果当前key不存在, 则进行set操作, 并且返回1.

 ![2020-01-18-22-04-00](http://img.couplecoders.tech/2020-01-18-22-04-00.png)

 那么此时的分布式锁流程是:


```shell
# 获取锁
setnx key value
if 0:
    放弃
if 1:
    成功,做业务操作

# 释放锁
del lock_key
```

**服务宕机**

下一个问题来了, 如果进程A在获取到了锁之后, 挂掉了, 也就是做不了释放锁的操作了. 那么这个锁永远的被线程A占用了, 其他任何的进程都拿不到了, 也就是造成了死锁问题. 这可是真*死锁*, 死的透透的.

解决方式是给key设置一个过期时间, 不管怎么样, 在过了这段时间, 自动删除key, 也就是释放了锁.

此时分布式锁的流程是:

```shell
# 获取锁
setnx lock_key 1
if 0:
    放弃
if 1:
    # 加个10s的过期时间
    expire lock_key 10
    成功,做业务操作

# 释放锁
del lock_key
```

我们加了10s的过期时间, 业务操作必须在10s内完成并且释放锁, 否则到了10s立即释放锁, 让别人用.

**又是原子性**

可以发现, 获取锁的过程又变成了两个命令, 又不能保证原子性了, 如果`setnx`之后服务立即宕机, 那么还是不能解决死锁的问题.也就是我们需要把这两个操作变成原子的.

也许你会原子性不是事务最擅长的嘛, 用Redis事务来进行, 但是不行, expire是否执行依赖于setnx执行的结果, 事务里可不提供if/else语句.

但是Redis提供了Lua脚本机制, 我们可以写个lua脚本发过去, 这样可以保证原子性.

当然, 在Redis 2.8之后, Redis作者为Redis提供了






## 参考文章


<br>


完。
<br>
<br>
<br>


## 联系我
最后，欢迎关注我的个人公众号【 呼延十 】，会不定期更新很多后端工程师的学习笔记。
也欢迎直接公众号私信或者邮箱联系我，一定知无不言，言无不尽。
![](http://img.couplecoders.tech/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png)


<br>
<br>




**以上皆为个人所思所得，如有错误欢迎评论区指正。**


**欢迎转载，烦请署名并保留原文链接。**


**联系邮箱：huyanshi2580@gmail.com**


**更多学习笔记见个人博客或关注微信公众号 &lt;呼延十 &gt;------><a href="{{ site.baseurl }}/">呼延十</a>**